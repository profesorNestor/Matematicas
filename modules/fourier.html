<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de Series de Fourier - Edición Cósmica</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.1/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/nerdamer.core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Algebra.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Calculus.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/nerdamer@1.1.13/Solve.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;900&display=swap');
        
        :root {
            --bg-dark: #020617;
            --bg-panel: rgba(15, 23, 42, 0.6);
            --glass-border: rgba(56, 189, 248, 0.2);
            --glass-border-hover: rgba(56, 189, 248, 0.5);
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --accent-primary: #22d3ee;
            --accent-secondary: #f43f5e;
            --accent-glow: rgba(34, 211, 238, 0.5);
            --shadow-color: rgba(0, 0, 0, 0.5);
        }

        html, body {
            height: 100%;
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
        }

        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.3;
        }

        .app-container {
            position: relative;
            z-index: 1;
            display: grid;
            /* CAMBIO: Panel de control más estrecho para un gráfico más grande */
            grid-template-columns: 380px 1fr;
            gap: 1.5rem;
            height: 100vh;
            padding: 1.5rem;
        }

        .glass-panel {
            background: var(--bg-panel);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            box-shadow: 0 8px 32px var(--shadow-color);
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 1.5rem;
            overflow-y: auto;
        }

        .main-content {
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px var(--accent-glow);
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.9rem;
        }

        .modern-input {
            width: 100%;
            padding: 12px 16px;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            transition: all 0.3s ease;
            outline: none;
        }

        .modern-input:focus {
            border-color: var(--accent-primary);
            box-shadow: 0 0 15px var(--accent-glow);
        }

        .action-button {
            background: linear-gradient(135deg, var(--accent-primary) 0%, #0ea5e9 100%);
            color: var(--bg-dark);
            font-weight: 700;
            padding: 14px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(34, 211, 238, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .action-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px var(--accent-glow);
        }
        
        .slider-group {
            padding: 1rem 0.5rem;
        }
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: var(--glass-border);
            outline: none;
            border-radius: 2px;
            transition: opacity .2s;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent-glow);
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
        }

        .graph-container {
            flex-grow: 1;
            position: relative;
            background: rgba(0,0,0,0.3);
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid var(--glass-border);
        }
        #canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        #canvas:active { cursor: grabbing; }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(2, 6, 23, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center; justify-content: center;
            z-index: 1000; padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .modal-overlay.active { display: flex; opacity: 1; }
        
        .modal-content {
            background: var(--bg-panel);
            padding: 2rem;
            border-radius: 24px;
            border: 1px solid var(--glass-border);
            max-width: 900px;
            width: 100%;
            max-height: 90vh;
            box-shadow: 0 10px 40px var(--shadow-color);
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        #formulas-content {
            font-size: 1.2rem;
            line-height: 2.5;
            overflow: auto;
            padding-right: 1rem;
        }
        #formulas-content h3 {
            font-size: 1.5rem;
            color: var(--accent-primary);
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: 0.5rem;
        }
        
        .loading-spinner {
            width: 50px; height: 50px;
            border: 4px solid var(--glass-border);
            border-top: 4px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        .function-type-selector {
            display: flex;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 4px;
            margin-bottom: 1rem;
        }
        .type-btn {
            flex: 1;
            padding: 8px;
            background: transparent;
            border: none;
            border-radius: 9px;
            color: var(--text-secondary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .type-btn.active {
            background: var(--accent-primary);
            color: var(--bg-dark);
            box-shadow: 0 0 10px var(--accent-glow);
        }

        .piecewise-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .piece-group {
            padding: 1rem;
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            background: rgba(0,0,0,0.2);
        }

        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 0.75rem;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            transition: background 0.2s ease;
        }
        .collapsible-header:hover {
            background: rgba(0,0,0,0.4);
        }
        .collapsible-title {
            font-weight: 600;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .collapsible-icon {
            transition: transform 0.3s ease-out;
            font-style: normal;
        }
        .collapsible-content {
            padding: 1rem 0.5rem 0.5rem;
            display: none;
        }
        .color-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .modern-color-picker {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 32px;
            height: 32px;
            background-color: transparent;
            border: none;
            cursor: pointer;
        }
        .modern-color-picker::-webkit-color-swatch {
            border-radius: 50%;
            border: 2px solid var(--glass-border);
        }
        .modern-color-picker::-moz-color-swatch {
            border-radius: 50%;
            border: 2px solid var(--glass-border);
        }

        @media (max-width: 1024px) {
            .app-container {
                grid-template-columns: 1fr;
                height: auto;
                padding: 1rem;
            }
            html, body { overflow: auto; }
            .control-panel { order: 2; }
            .main-content { order: 1; min-height: 60vh; }
        }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: var(--glass-border); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    </style>
</head>
<body>
    <canvas id="particle-canvas"></canvas>

    <div class="app-container">
        <!-- Panel de Control (Izquierda) -->
        <aside class="glass-panel control-panel">
            <h1 class="panel-title text-2xl">Visualizador de Fourier</h1>
            
            <div class="input-group">
                <div class="collapsible-header">
                    <span class="collapsible-title">🎨 Paleta de Colores</span>
                    <i class="collapsible-icon">+</i>
                </div>
                <div class="collapsible-content">
                    <div class="color-control">
                        <label>Función Original</label>
                        <input type="color" id="original-color-picker" class="modern-color-picker" value="#ffc700">
                    </div>
                    <div class="color-control">
                        <label>Serie de Fourier</label>
                        <input type="color" id="fourier-color-picker" class="modern-color-picker" value="#22d3ee">
                    </div>
                </div>
            </div>
            
            <div class="function-type-selector">
                <button class="type-btn active" data-type="normal">Normal</button>
                <button class="type-btn" data-type="piecewise">A Trozos</button>
            </div>

            <div id="normal-input-container">
                <div class="input-group">
                    <label for="function-input" class="input-label">Función f(x)</label>
                    <input type="text" class="modern-input" id="function-input" placeholder="Ej: x, sin(x), x^2" value="x">
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div class="input-group">
                        <label for="period-start" class="input-label">Inicio del Período</label>
                        <input type="number" class="modern-input" id="period-start" value="-3.14159" step="0.1">
                    </div>
                    <div class="input-group">
                        <label for="period-end" class="input-label">Fin del Período</label>
                        <input type="number" class="modern-input" id="period-end" value="3.14159" step="0.1">
                    </div>
                </div>
            </div>

            <div id="piecewise-input-container" class="hidden">
                <div class="piecewise-container">
                    <div class="piece-group">
                        <label class="input-label">Trozo 1</label>
                        <input type="text" class="modern-input mb-2" id="p1-func" value="-1">
                        <div class="grid grid-cols-2 gap-2">
                            <input type="number" class="modern-input" id="p1-start" value="-3.14159">
                            <input type="number" class="modern-input" id="p1-end" value="0">
                        </div>
                    </div>
                    <div class="piece-group">
                        <label class="input-label">Trozo 2</label>
                        <input type="text" class="modern-input mb-2" id="p2-func" value="1">
                        <div class="grid grid-cols-2 gap-2">
                            <input type="number" class="modern-input" id="p2-start" value="0">
                            <input type="number" class="modern-input" id="p2-end" value="3.14159">
                        </div>
                    </div>
                </div>
            </div>

            <div class="input-group slider-group">
                <div class="flex justify-between items-center mb-2">
                    <label for="terms-slider" class="input-label mb-0">Número de Armónicos (N)</label>
                    <span id="terms-value" class="font-bold text-lg text-accent-primary">10</span>
                </div>
                <input type="range" min="1" max="50" value="10" class="slider" id="terms-slider">
            </div>

            <div class="flex gap-4 mt-2">
                <button id="calculate-button" class="action-button w-full">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/></svg>
                    <span>Calcular</span>
                </button>
                <button id="show-formulas-btn" class="action-button w-full" style="background: var(--bg-panel); color: var(--text-primary); display:none;">
                     <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg>
                    <span>Fórmulas</span>
                </button>
            </div>
            
            <div id="status-container" class="text-center text-sm text-text-secondary mt-4 h-5"></div>

            <div class="mt-auto pt-4 border-t border-glass-border">
                <h3 class="panel-title text-lg">Coeficientes Calculados</h3>
                <div class="h-48 overflow-y-auto pr-2" id="coefficients-container">
                    <p class="text-center text-text-secondary text-sm">Los coeficientes aparecerán aquí...</p>
                </div>
            </div>
        </aside>

        <!-- Panel Principal (Derecha) -->
        <main class="main-content">
            <div class="graph-container">
                <canvas id="canvas"></canvas>
            </div>
        </main>
    </div>
    
    <!-- Modal para Fórmulas -->
    <div id="formulas-modal" class="modal-overlay">
        <div class="modal-content">
            <div id="formulas-content"></div>
            <button id="close-formulas-modal" class="action-button mt-6 self-center">Cerrar</button>
        </div>
    </div>
    
    <!-- Modal para Carga -->
    <div id="loading-modal" class="modal-overlay">
        <div class="loading-spinner"></div>
    </div>

    <script>
    // --- PARTICLE ANIMATION ---
    const particleCanvas = document.getElementById('particle-canvas');
    const particleCtx = particleCanvas.getContext('2d');
    let particles = [];
    
    function setupParticleCanvas() {
        particleCanvas.width = window.innerWidth;
        particleCanvas.height = window.innerHeight;
    }
    setupParticleCanvas();

    class Particle {
        constructor(x, y, dirX, dirY, size, color) {
            this.x = x; this.y = y; this.dirX = dirX; this.dirY = dirY;
            this.size = size; this.color = color;
        }
        draw() {
            particleCtx.beginPath();
            particleCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
            particleCtx.fillStyle = this.color;
            particleCtx.fill();
        }
        update() {
            if (this.x > particleCanvas.width || this.x < 0) this.dirX = -this.dirX;
            if (this.y > particleCanvas.height || this.y < 0) this.dirY = -this.dirY;
            this.x += this.dirX; this.y += this.dirY;
            this.draw();
        }
    }

    function initParticles() {
        particles = [];
        let numParticles = (particleCanvas.height * particleCanvas.width) / 30000;
        for (let i = 0; i < numParticles; i++) {
            let size = Math.random() * 2 + 1;
            let x = Math.random() * (innerWidth - size * 2) + size * 2;
            let y = Math.random() * (innerHeight - size * 2) + size * 2;
            let dirX = (Math.random() * 0.4) - 0.2;
            let dirY = (Math.random() * 0.4) - 0.2;
            let color = 'rgba(34, 211, 238, ' + (Math.random() * 0.5) + ')';
            particles.push(new Particle(x, y, dirX, dirY, size, color));
        }
    }

    function animateParticles() {
        requestAnimationFrame(animateParticles);
        particleCtx.clearRect(0, 0, innerWidth, innerHeight);
        particles.forEach(p => p.update());
    }
    initParticles();
    animateParticles();
    window.addEventListener('resize', () => {
        setupParticleCanvas();
        initParticles();
    });

    // --- FOURIER ANALYSIS SCRIPT ---
    document.addEventListener('DOMContentLoaded', () => {
        const dom = {
            canvas: document.getElementById('canvas'),
            functionInput: document.getElementById('function-input'),
            periodStartInput: document.getElementById('period-start'),
            periodEndInput: document.getElementById('period-end'),
            termsSlider: document.getElementById('terms-slider'),
            termsValue: document.getElementById('terms-value'),
            calculateButton: document.getElementById('calculate-button'),
            showFormulasBtn: document.getElementById('show-formulas-btn'),
            closeFormulasModal: document.getElementById('close-formulas-modal'),
            formulasModal: document.getElementById('formulas-modal'),
            formulasContent: document.getElementById('formulas-content'),
            loadingModal: document.getElementById('loading-modal'),
            statusContainer: document.getElementById('status-container'),
            coefficientsContainer: document.getElementById('coefficients-container'),
            functionTypeSelector: document.querySelector('.function-type-selector'),
            normalInputContainer: document.getElementById('normal-input-container'),
            piecewiseInputContainer: document.getElementById('piecewise-input-container'),
            originalColorPicker: document.getElementById('original-color-picker'),
            fourierColorPicker: document.getElementById('fourier-color-picker'),
        };

        const ctx = dom.canvas.getContext('2d');
        let coefficients = { a0: 0, an: [], bn: [] };
        
        // CAMBIO: Objeto de vista actualizado para escalado de ejes
        let view = {
            zoomX: 50,
            zoomY: 50,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            isScaling: false,
            scalingAxis: 'none', // 'x', 'y', or 'none'
            hoveringAxis: 'none', // 'x', 'y', or 'none'
            lastX: 0,
            lastY: 0
        };

        let redrawQueued = false;
        let currentFunctionType = 'normal';
        let originalFunctionColor = dom.originalColorPicker.value;
        let fourierSeriesColor = dom.fourierColorPicker.value;

        // --- Initialization ---
        function initialize() {
            setupMainCanvas();
            addEventListeners();
            dom.calculateButton.click(); // Initial calculation
        }

        function setupMainCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = dom.canvas.parentElement.getBoundingClientRect();
            dom.canvas.width = rect.width * dpr;
            dom.canvas.height = rect.height * dpr;
            dom.canvas.style.width = `${rect.width}px`;
            dom.canvas.style.height = `${rect.height}px`;
        }

        function addEventListeners() {
            window.addEventListener('resize', () => {
                setupMainCanvas();
                requestRedraw();
            });
            
            dom.calculateButton.addEventListener('click', handleCalculation);
            dom.termsSlider.addEventListener('input', () => {
                dom.termsValue.textContent = dom.termsSlider.value;
                requestRedraw();
            });

            document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const icon = header.querySelector('.collapsible-icon');
                    const isHidden = content.style.display === 'none' || content.style.display === '';
                    content.style.display = isHidden ? 'block' : 'none';
                    icon.style.transform = isHidden ? 'rotate(45deg)' : 'rotate(0deg)';
                });
            });

            dom.originalColorPicker.addEventListener('input', (e) => {
                originalFunctionColor = e.target.value;
                requestRedraw();
            });
            dom.fourierColorPicker.addEventListener('input', (e) => {
                fourierSeriesColor = e.target.value;
                requestRedraw();
            });

            dom.functionTypeSelector.addEventListener('click', (e) => {
                if (e.target.matches('.type-btn')) {
                    currentFunctionType = e.target.dataset.type;
                    document.querySelectorAll('.type-btn').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    
                    const isNormal = currentFunctionType === 'normal';
                    dom.normalInputContainer.classList.toggle('hidden', !isNormal);
                    dom.piecewiseInputContainer.classList.toggle('hidden', isNormal);
                }
            });

            // CAMBIO: Eventos de ratón actualizados para paneo, zoom y escalado de ejes
            dom.canvas.addEventListener('mousedown', e => {
                if (view.hoveringAxis !== 'none') {
                    view.isScaling = true;
                    view.scalingAxis = view.hoveringAxis;
                    view.isDragging = false;
                } else {
                    view.isDragging = true;
                    view.isScaling = false;
                }
                view.lastX = e.offsetX;
                view.lastY = e.offsetY;
            });

            dom.canvas.addEventListener('mousemove', e => {
                const AXIS_HOVER_THRESHOLD = 10;
                const logicalMouseX = e.offsetX;
                const logicalMouseY = e.offsetY;

                if (view.isScaling) {
                    const worldCoords = screenToWorld(logicalMouseX, logicalMouseY);
                    const dx = logicalMouseX - view.lastX;
                    const dy = logicalMouseY - view.lastY;

                    if (view.scalingAxis === 'x') { // Escalar eje X (arrastre horizontal)
                        const scaleFactor = 1 - (dx * 0.01);
                        view.zoomX *= scaleFactor;
                        dom.canvas.style.cursor = 'ew-resize';
                    } else if (view.scalingAxis === 'y') { // Escalar eje Y (arrastre vertical)
                        const scaleFactor = 1 - (dy * 0.01);
                        view.zoomY *= scaleFactor;
                        dom.canvas.style.cursor = 'ns-resize';
                    }
                    
                    const newWorldCoords = screenToWorld(logicalMouseX, logicalMouseY);
                    view.offsetX += worldCoords.x - newWorldCoords.x;
                    view.offsetY += worldCoords.y - newWorldCoords.y;

                    view.lastX = logicalMouseX;
                    view.lastY = logicalMouseY;
                    requestRedraw();

                } else if (view.isDragging) {
                    const dx = logicalMouseX - view.lastX;
                    const dy = logicalMouseY - view.lastY;
                    view.offsetX += dx / view.zoomX;
                    view.offsetY -= dy / view.zoomY;
                    view.lastX = logicalMouseX;
                    view.lastY = logicalMouseY;
                    dom.canvas.style.cursor = 'grabbing';
                    requestRedraw();
                } else {
                    const origin = worldToScreen(0, 0);
                    if (Math.abs(logicalMouseY - origin.y) < AXIS_HOVER_THRESHOLD) {
                        view.hoveringAxis = 'x';
                        dom.canvas.style.cursor = 'ew-resize';
                    } else if (Math.abs(logicalMouseX - origin.x) < AXIS_HOVER_THRESHOLD) {
                        view.hoveringAxis = 'y';
                        dom.canvas.style.cursor = 'ns-resize';
                    } else {
                        view.hoveringAxis = 'none';
                        dom.canvas.style.cursor = 'grab';
                    }
                }
            });
            
            dom.canvas.addEventListener('mouseup', () => {
                view.isDragging = false;
                view.isScaling = false;
                view.scalingAxis = 'none';
            });

            dom.canvas.addEventListener('mouseleave', () => {
                view.isDragging = false;
                view.isScaling = false;
                view.scalingAxis = 'none';
                view.hoveringAxis = 'none';
                dom.canvas.style.cursor = 'grab';
            });

            dom.canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const logicalMouseX = e.offsetX;
                const logicalMouseY = e.offsetY;
                const worldCoords = screenToWorld(logicalMouseX, logicalMouseY);
                
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                view.zoomX *= zoomFactor;
                view.zoomY *= zoomFactor;

                const newWorldCoords = screenToWorld(logicalMouseX, logicalMouseY);
                view.offsetX += worldCoords.x - newWorldCoords.x;
                view.offsetY += worldCoords.y - newWorldCoords.y;

                requestRedraw();
            });
            
            dom.showFormulasBtn.addEventListener('click', () => dom.formulasModal.classList.add('active'));
            dom.closeFormulasModal.addEventListener('click', () => dom.formulasModal.classList.remove('active'));
            dom.formulasModal.addEventListener('click', e => {
                if (e.target === dom.formulasModal) dom.formulasModal.classList.remove('active');
            });
        }
        
        async function handleCalculation() {
            dom.loadingModal.classList.add('active');
            dom.statusContainer.textContent = "Calculando coeficientes...";
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                let funcData = getFunctionDataFromDOM();
                const T = funcData.end - funcData.start;
                const L = T / 2;
                const maxTerms = 50;
                
                const evalFunc = createEvalFunction(funcData);
                const symData = await getSymbolicFormulas(funcData, L);

                coefficients.a0 = (1 / L) * numericalIntegration(evalFunc, funcData.start, funcData.end);
                coefficients.an = [];
                coefficients.bn = [];

                for (let n = 1; n <= maxTerms; n++) {
                    coefficients.an.push((1 / L) * numericalIntegration(x => evalFunc(x) * Math.cos(n * Math.PI * x / L), funcData.start, funcData.end));
                    coefficients.bn.push((1 / L) * numericalIntegration(x => evalFunc(x) * Math.sin(n * Math.PI * x / L), funcData.start, funcData.end));
                }
                
                displayCoefficients();
                updateFormulasDisplay(funcData, T, L, symData);
                dom.showFormulasBtn.style.display = 'flex';
                dom.statusContainer.textContent = "Cálculo completado.";
                requestRedraw();

            } catch (error) {
                console.error("Calculation Error:", error);
                dom.statusContainer.textContent = "Error en la función ingresada.";
            } finally {
                dom.loadingModal.classList.remove('active');
            }
        }
        
        function createEvalFunction(funcData) {
            if (funcData.type === 'normal') {
                return (x) => math.evaluate(funcData.funcStr, { x, pi: Math.PI, e: Math.E });
            } else {
                return (x) => {
                    for (const piece of funcData.pieces) {
                        if (x >= piece.start && x < piece.end) {
                            return math.evaluate(piece.func, { x, pi: Math.PI, e: Math.E });
                        }
                    }
                    return 0;
                };
            }
        }

        async function getSymbolicFormulas(funcData, L) {
            try {
                nerdamer.set('integration_depth', 40);
                if (funcData.type === 'normal') {
                    const { funcStr, start, end } = funcData;
                    return {
                        a0_sym: nerdamer.defint(`(1/${L}) * (${funcStr})`, 'x', start, end).toTeX(),
                        an_sym: nerdamer.defint(`(1/${L}) * (${funcStr}) * cos(n*pi*x/${L})`, 'x', start, end).toTeX(),
                        bn_sym: nerdamer.defint(`(1/${L}) * (${funcStr}) * sin(n*pi*x/${L})`, 'x', start, end).toTeX(),
                    };
                } else {
                    let a0_sym = '', an_sym = '', bn_sym = '';
                    funcData.pieces.forEach((p, i) => {
                        if (i > 0) { a0_sym += '+'; an_sym += '+'; bn_sym += '+'; }
                        a0_sym += `\\int_{${p.start}}^{${p.end}} (${p.func}) \\,dx`;
                        an_sym += `\\int_{${p.start}}^{${p.end}} (${p.func}) \\cos(\\frac{n\\pi x}{${L.toFixed(3)}}) \\,dx`;
                        bn_sym += `\\int_{${p.start}}^{${p.end}} (${p.func}) \\sin(\\frac{n\\pi x}{${L.toFixed(3)}}) \\,dx`;
                    });
                    return {
                        a0_sym: `\\frac{1}{${L.toFixed(3)}} \\left[ ${a0_sym} \\right]`,
                        an_sym: `\\frac{1}{${L.toFixed(3)}} \\left[ ${an_sym} \\right]`,
                        bn_sym: `\\frac{1}{${L.toFixed(3)}} \\left[ ${bn_sym} \\right]`,
                    };
                }
            } catch (e) {
                console.warn("Symbolic integration failed.", e);
                return { a0_sym: "\\text{Cálculo Numérico}", an_sym: "\\text{Cálculo Numérico}", bn_sym: "\\text{Cálculo Numérico}" };
            }
        }

        function numericalIntegration(fn, a, b, n = 1000) {
            const h = (b - a) / n;
            let sum = 0.5 * (fn(a) + fn(b));
            for (let i = 1; i < n; i++) {
                sum += fn(a + i * h);
            }
            return sum * h;
        }
        
        function requestRedraw() {
            if (!redrawQueued) {
                redrawQueued = true;
                requestAnimationFrame(() => {
                    drawScene();
                    redrawQueued = false;
                });
            }
        }

        function drawScene() {
            const dpr = window.devicePixelRatio || 1;
            const { width, height } = dom.canvas;

            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, width, height);
            ctx.scale(dpr, dpr);

            drawGrid();

            if (coefficients.an.length > 0) {
                const funcData = getFunctionDataFromDOM();
                const evalFunc = createEvalFunction(funcData);
                drawFunction(evalFunc, originalFunctionColor, 3.5);
                drawFunction(fourierSeries, fourierSeriesColor, 2.5);
            }

            ctx.restore();
        }
        
        function getFunctionDataFromDOM() {
            if (currentFunctionType === 'normal') {
                return {
                    type: 'normal',
                    funcStr: dom.functionInput.value,
                    start: parseFloat(dom.periodStartInput.value),
                    end: parseFloat(dom.periodEndInput.value),
                };
            } else {
                const p1 = {
                    func: document.getElementById('p1-func').value,
                    start: parseFloat(document.getElementById('p1-start').value),
                    end: parseFloat(document.getElementById('p1-end').value),
                };
                const p2 = {
                    func: document.getElementById('p2-func').value,
                    start: parseFloat(document.getElementById('p2-start').value),
                    end: parseFloat(document.getElementById('p2-end').value),
                };
                return {
                    type: 'piecewise',
                    pieces: [p1, p2],
                    start: Math.min(p1.start, p2.start),
                    end: Math.max(p1.end, p2.end),
                };
            }
        }

        // CAMBIO: Lógica de la cuadrícula actualizada para usar zoomX y zoomY
        function drawGrid() {
            const { width, height } = dom.canvas;
            const dpr = window.devicePixelRatio || 1;
            const w = width / dpr;
            const h = height / dpr;

            const { x: xMin, y: yMax } = screenToWorld(0, 0);
            const { x: xMax, y: yMin } = screenToWorld(w, h);

            ctx.strokeStyle = "rgba(56, 189, 248, 0.15)";
            ctx.lineWidth = 1;
            
            const xStep = Math.pow(10, Math.floor(Math.log10(w / view.zoomX)) - 1) * 5;
            const yStep = Math.pow(10, Math.floor(Math.log10(h / view.zoomY)) - 1) * 5;

            for (let i = Math.floor(xMin / xStep) * xStep; i <= xMax; i += xStep) {
                const sx = worldToScreen(i, 0).x;
                ctx.beginPath();
                ctx.moveTo(sx, 0);
                ctx.lineTo(sx, h);
                ctx.stroke();
            }
            for (let i = Math.floor(yMin / yStep) * yStep; i <= yMax; i += yStep) {
                const sy = worldToScreen(0, i).y;
                ctx.beginPath();
                ctx.moveTo(0, sy);
                ctx.lineTo(w, sy);
                ctx.stroke();
            }

            ctx.strokeStyle = "rgba(226, 232, 240, 0.8)";
            ctx.lineWidth = 2;
            const origin = worldToScreen(0, 0);
            ctx.beginPath();
            ctx.moveTo(0, origin.y); ctx.lineTo(w, origin.y);
            ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, h);
            ctx.stroke();
            
            ctx.fillStyle = "rgba(226, 232, 240, 0.9)";
            ctx.font = `${12}px Inter`;
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            for (let i = Math.floor(xMin / xStep) * xStep; i <= xMax; i += xStep) {
                if (Math.abs(i) < 1e-9) continue;
                const sx = worldToScreen(i, 0).x;
                ctx.fillText(i.toPrecision(2), sx, origin.y + 5);
            }
            
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let i = Math.floor(yMin / yStep) * yStep; i <= yMax; i += yStep) {
                if (Math.abs(i) < 1e-9) continue;
                const sy = worldToScreen(0, i).y;
                if (sy > 0 && sy < h) {
                    ctx.fillText(i.toPrecision(2), origin.x - 5, sy);
                }
            }
        }

        function drawFunction(evalFunc, color, lineWidth) {
            const { width } = dom.canvas;
            const dpr = window.devicePixelRatio || 1;
            const w = width / dpr;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.shadowColor = color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            
            let firstPoint = true;
            for (let sx = 0; sx <= w; sx += 1) {
                const worldX = screenToWorld(sx, 0).x;
                try {
                    const worldY = evalFunc(worldX);
                    if (isFinite(worldY)) {
                        const { x, y } = worldToScreen(worldX, worldY);
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    } else {
                        firstPoint = true;
                    }
                } catch (e) { firstPoint = true; }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
        
        function fourierSeries(x) {
            const funcData = getFunctionDataFromDOM();
            const L = (funcData.end - funcData.start) / 2;
            const N = parseInt(dom.termsSlider.value);
            let sum = coefficients.a0 / 2;
            for (let n = 1; n <= N; n++) {
                sum += coefficients.an[n - 1] * Math.cos(n * Math.PI * x / L);
                sum += coefficients.bn[n - 1] * Math.sin(n * Math.PI * x / L);
            }
            return sum;
        }

        function displayCoefficients() {
            let html = '';
            html += `<div class="p-2 rounded-lg bg-black/20"><strong>a₀ =</strong> <span class="font-mono text-accent-primary">${coefficients.a0.toFixed(5)}</span></div>`;
            for (let i = 0; i < 10; i++) {
                if (coefficients.an[i] === undefined) break;
                html += `<div class="p-2 mt-2 rounded-lg bg-black/20 grid grid-cols-2 gap-2">
                                 <div><strong>a<sub>${i+1}</sub> =</strong> <span class="font-mono text-accent-primary">${coefficients.an[i].toFixed(5)}</span></div>
                                 <div><strong>b<sub>${i+1}</sub> =</strong> <span class="font-mono text-accent-primary">${coefficients.bn[i].toFixed(5)}</span></div>
                               </div>`;
            }
            dom.coefficientsContainer.innerHTML = html;
        }
        
        function updateFormulasDisplay(funcData, T, L, sym) {
            const L_str = L.toFixed(3);
            let funcDefHTML = '';
            let calcHTML = '';

            if (funcData.type === 'normal') {
                funcDefHTML = `f(x) = ${funcData.funcStr}`;
                calcHTML = `<p>\\[ a_0 = \\frac{1}{${L_str}} \\int_{${funcData.start.toFixed(3)}}^{${funcData.end.toFixed(3)}} (${funcData.funcStr}) \\,dx \\approx ${coefficients.a0.toFixed(5)} \\]</p>
                                <p>Resultado simbólico para \\(a_n\\): \\( ${sym.an_sym} \\)</p>
                                <p>Resultado simbólico para \\(b_n\\): \\( ${sym.bn_sym} \\)</p>`;
            } else {
                funcDefHTML = `f(x) = \\begin{cases} ${funcData.pieces[0].func} & \\text{si } ${funcData.pieces[0].start.toFixed(3)} \\le x < ${funcData.pieces[0].end.toFixed(3)} \\\\ ${funcData.pieces[1].func} & \\text{si } ${funcData.pieces[1].start.toFixed(3)} \\le x < ${funcData.pieces[1].end.toFixed(3)} \\end{cases}`;
                calcHTML = `<p>\\[ a_n = ${sym.an_sym} \\]</p>
                                <p>\\[ b_n = ${sym.bn_sym} \\]</p>`;
            }
            
            dom.formulasContent.innerHTML = `
                <h3>Definiciones Generales</h3>
                <p>\\[ f(x) \\approx \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left( a_n \\cos\\left(\\frac{n\\pi x}{L}\\right) + b_n \\sin\\left(\\frac{n\\pi x}{L}\\right) \\right) \\]</p>
                <p>\\[ a_n = \\frac{1}{L} \\int_{-L}^{L} f(x) \\cos\\left(\\frac{n\\pi x}{L}\\right) \\,dx \\quad , \\quad b_n = \\frac{1}{L} \\int_{-L}^{L} f(x) \\sin\\left(\\frac{n\\pi x}{L}\\right) \\,dx \\]</p>
                
                <h3>Cálculo para ${funcDefHTML}</h3>
                ${calcHTML}

                <h3>Serie Resultante (Primeros Términos)</h3>
                <p>\\[ f(x) \\approx ${(coefficients.a0 / 2).toFixed(4)} 
                    ${generateSeriesString(L_str)}
                \\]</p>
            `;
            if (window.MathJax) {
                MathJax.typesetPromise([dom.formulasContent]).catch(err => console.error('MathJax Error:', err));
            }
        }
        
        function generateSeriesString(L_str) {
            let str = '';
            for (let n = 1; n <= 3; n++) {
                if (coefficients.an[n-1] === undefined) break;
                const an = coefficients.an[n-1];
                const bn = coefficients.bn[n-1];
                if (Math.abs(an) > 1e-4) str += ` ${an > 0 ? '+' : ''} ${an.toFixed(4)} \\cos(\\frac{${n}\\pi x}{${L_str}})`;
                if (Math.abs(bn) > 1e-4) str += ` ${bn > 0 ? '+' : ''} ${bn.toFixed(4)} \\sin(\\frac{${n}\\pi x}{${L_str}})`;
            }
            return str + ' + \\dots';
        }

        // CAMBIO: Transformaciones de coordenadas actualizadas para usar zoomX y zoomY
        function worldToScreen(x, y) {
            const { width, height } = dom.canvas;
            const dpr = window.devicePixelRatio || 1;
            const logicalWidth = width / dpr;
            const logicalHeight = height / dpr;
            return { 
                x: (logicalWidth / 2) + (x + view.offsetX) * view.zoomX, 
                y: (logicalHeight / 2) - (y - view.offsetY) * view.zoomY 
            };
        }
        function screenToWorld(sx, sy) {
            const { width, height } = dom.canvas;
            const dpr = window.devicePixelRatio || 1;
            const logicalWidth = width / dpr;
            const logicalHeight = height / dpr;
            return { 
                x: (sx - logicalWidth / 2) / view.zoomX - view.offsetX,
                y: (logicalHeight / 2 - sy) / view.zoomY + view.offsetY
            };
        }

        initialize();
    });
    </script>
</body>
</html>
