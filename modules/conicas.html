<!DOCTYPE html>
<html lang="es" class="dark">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simulador de Secciones Cónicas | Néstor Montoya & Gemini AI</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js" charset="utf-8"></script>
    
    <!-- Three.js & OrbitControls -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <!-- MathJax -->
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #111827; /* gray-900 */
            --card-bg: rgba(31, 41, 55, 0.5); /* gray-800 with alpha */
            --card-border: rgba(255, 255, 255, 0.1);
            --neumorph-bg: #1f2937; /* gray-800 */
            --neumorph-shadow-light: rgba(255, 255, 255, 0.05);
            --neumorph-shadow-dark: rgba(0, 0, 0, 0.5);
            --primary-accent: #38bdf8; /* sky-400 */
            --text-light: #f3f4f6; /* gray-100 */
            --text-dark: #9ca3af; /* gray-400 */
        }

        html { scroll-behavior: smooth; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            min-height: 100vh;
        }

        .glassmorphism {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--card-border);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .neumorph-inset {
            background: var(--neumorph-bg);
            box-shadow: inset 6px 6px 12px var(--neumorph-shadow-dark), inset -6px -6px 12px var(--neumorph-shadow-light);
        }

        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 8px;
            background: var(--neumorph-bg);
            border-radius: 8px;
            box-shadow: inset 3px 3px 6px var(--neumorph-shadow-dark), inset -3px -3px 6px var(--neumorph-shadow-light);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 24px; height: 24px;
            background: var(--primary-accent);
            border-radius: 50%; cursor: grab;
            box-shadow: 4px 4px 8px var(--neumorph-shadow-dark), -4px -4px 8px var(--neumorph-shadow-light);
            transition: transform 0.2s ease;
        }
        input[type="range"]:active::-webkit-slider-thumb {
            cursor: grabbing;
            transform: scale(1.1);
        }
        
        #info-panel::-webkit-scrollbar { width: 8px; height: 8px; }
        #info-panel::-webkit-scrollbar-track { background: var(--neumorph-bg); border-radius: 10px; }
        #info-panel::-webkit-scrollbar-thumb { background-color: var(--primary-accent); border-radius: 10px; border: 2px solid var(--neumorph-bg); }
    </style>
</head>

<body class="min-h-screen overflow-y-auto">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-5xl font-extrabold tracking-tight text-transparent bg-clip-text bg-gradient-to-r from-sky-400 to-cyan-300">
                Simulador de Secciones Cónicas
            </h1>
            <p id="main-equation" class="mt-3 text-lg text-gray-400">$r(\theta) = \frac{p}{1 + e \cdot \cos(\theta - \theta_0)}$</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-5 gap-8">
            
            <div class="lg:col-span-2 flex flex-col gap-8">
                
                <div class="glassmorphism rounded-2xl p-6">
                    <h2 class="text-xl font-bold text-sky-400 mb-6">Parámetros Geométricos</h2>
                    <div class="space-y-6">
                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <label for="e" class="font-medium text-sm whitespace-nowrap">Excentricidad ($e$)</label>
                                <span id="e-value-display" class="font-mono text-sm bg-gray-900/50 text-sky-300 py-1 px-3 rounded-full ml-4">0.50</span>
                            </div>
                            <input id="e" type="range" min="0" max="2" step="0.01" value="0.5">
                        </div>
                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <label for="p" class="font-medium text-sm whitespace-nowrap">Semilatus Rectum ($p$)</label>
                                <span id="p-value-display" class="font-mono text-sm bg-gray-900/50 text-sky-300 py-1 px-3 rounded-full ml-4">4.0</span>
                            </div>
                            <input id="p" type="range" min="0.1" max="10" step="0.1" value="4.0">
                        </div>
                        <div>
                            <label for="theta0" class="font-medium text-sm mb-2 block">Orientación ($\theta_0$)</label>
                            <select id="theta0" class="w-full neumorph-inset p-3 text-sm rounded-lg focus:ring-2 focus:ring-sky-400 focus:outline-none appearance-none">
                                <option value="0">Vertical, apertura izquierda</option>
                                <option value="180">Vertical, apertura derecha</option>
                                <option value="90">Horizontal, apertura abajo</option>
                                <option value="270" selected>Horizontal, apertura arriba</option>
                            </select>
                        </div>
                        <div id="branch-toggle-container" class="hidden">
                            <label class="flex items-center gap-2 text-xs cursor-pointer">
                              <input id="branch-toggle" type="checkbox" class="accent-sky-400 w-4 h-4">
                              Mostrar ambas ramas
                            </label>
                        </div>
                    </div>
                </div>

                <div class="glassmorphism rounded-2xl p-6 flex flex-col">
                     <h2 class="text-xl font-bold text-sky-400 mb-4">Datos Analíticos</h2>
                     <div id="info-panel" class="text-sm space-y-3 text-gray-300 max-h-[450px] overflow-auto pr-2">
                     </div>
                </div>

            </div>

            <div class="lg:col-span-3 min-h-[60vh] lg:min-h-0 neumorph-inset rounded-2xl p-2 relative">
                <div id="plot-container" class="w-full h-full rounded-xl overflow-hidden"></div>
                <div id="three-d-container" class="w-full h-full absolute top-0 left-0 rounded-xl overflow-hidden pointer-events-none opacity-0 transition-opacity duration-500"></div>

                <div class="absolute top-4 right-4 z-20 flex items-center gap-2 p-2 rounded-full glassmorphism">
                    <button id="palette-toggle" aria-label="Cambiar color de la curva" class="p-2 rounded-full hover:bg-gray-700/50 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path><path d="m12 13.01 3.5-3.5a2.12 2.12 0 1 0-3-3L12 7.01"></path></svg>
                    </button>
                    <button id="asymptote-palette-toggle" aria-label="Cambiar color de asíntotas" class="p-2 rounded-full hover:bg-gray-700/50 transition-colors hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                    </button>
                    <button id="view-toggle" aria-label="Cambiar vista" class="p-2 w-10 h-10 flex items-center justify-center rounded-full hover:bg-gray-700/50 transition-colors font-bold text-sm">3D</button>
                    <button id="home-button" aria-label="Reiniciar vista" class="p-2 rounded-full hover:bg-gray-700/50 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
                    </button>
                </div>

                <div id="color-palette-widget" class="absolute top-20 right-4 z-20 p-4 rounded-2xl glassmorphism opacity-0 pointer-events-none transition-all duration-300 transform scale-95 -translate-y-2">
                    <p class="text-sm font-bold text-center mb-3">Color de la Curva</p>
                    <div id="color-swatches" class="grid grid-cols-5 gap-3">
                    </div>
                </div>
                
                <div id="asymptote-color-palette-widget" class="absolute top-20 right-4 z-20 p-4 rounded-2xl glassmorphism opacity-0 pointer-events-none transition-all duration-300 transform scale-95 -translate-y-2">
                    <p class="text-sm font-bold text-center mb-3">Color de Asíntotas</p>
                    <div id="asymptote-color-swatches" class="grid grid-cols-5 gap-3">
                    </div>
                </div>
                
                <div id="controls-3d" class="absolute bottom-4 left-1/2 -translate-x-1/2 z-20 flex items-center gap-2 p-2 rounded-full glassmorphism opacity-0 pointer-events-none transition-opacity">
                    <button id="solid-btn" class="px-3 py-1 text-xs rounded-full bg-sky-500/20">Sólido</button>
                    <button id="wireframe-btn" class="px-3 py-1 text-xs rounded-full bg-sky-500/20">Malla</button>
                    <button id="both-btn" class="px-3 py-1 text-xs rounded-full bg-sky-500/50">Ambos</button>
                </div>

            </div>
        </main>
        
        <footer class="text-center text-gray-500 text-sm mt-12 pb-4">
            Autor: Msc Néstor Fabio Montoya Palacios & Gemini AI
        </footer>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const $ = (selector) => document.querySelector(selector);
        
        const dom = {
            eSlider: $('#e'), pSlider: $('#p'), theta0Select: $('#theta0'),
            eValueDisplay: $('#e-value-display'), pValueDisplay: $('#p-value-display'),
            infoPanel: $('#info-panel'), plotContainer: $('#plot-container'),
            threeContainer: $('#three-d-container'), viewToggle: $('#view-toggle'),
            homeButton: $('#home-button'),
            controls3D: $('#controls-3d'), solidBtn: $('#solid-btn'),
            wireframeBtn: $('#wireframe-btn'), bothBtn: $('#both-btn'),
            paletteToggle: $('#palette-toggle'),
            paletteWidget: $('#color-palette-widget'),
            colorSwatchesContainer: $('#color-swatches'),
            asymptotePaletteToggle: $('#asymptote-palette-toggle'),
            asymptotePaletteWidget: $('#asymptote-color-palette-widget'),
            asymptoteColorSwatchesContainer: $('#asymptote-color-swatches'),
            branchToggleContainer: $('#branch-toggle-container'),
            branchToggle: $('#branch-toggle'),
        };

        const RAD = Math.PI / 180;
        const PRECISION = 2;
        let showBothBranches = false;
        
        const conicColors = ['#38bdf8', '#fb7185', '#4ade80', '#facc15', '#a78bfa', '#2dd4bf', '#f87171', '#c084fc', '#fbbf24', '#34d399'];
        const asymptoteColors = ['#f97316', '#9ca3af', '#a16207', '#16a34a', '#be123c', '#6d28d9', '#0e7490', '#b91c1c', '#4a044e', '#065f46'];

        let state = { 
            e: 0.5, 
            p: 4.0, 
            theta0: 270, 
            show3D: false, 
            currentColor: conicColors[0], 
            asymptoteColor: asymptoteColors[0]
        };
        let three = { scene: null, camera: null, renderer: null, meshes: [], controls: null, animationFrameId: null };

        function calculateConicProperties() {
            const { e, p } = state;
            const theta0Deg = state.theta0;
            const theta0Rad = theta0Deg * RAD;
            
            let props = { e, p, theta0Rad, type: '', vertices: [], foci: [], center: null, asymptotes: [], directrices: [], cartesianEq: {}, boundingBox: {} };

            if (e === 0) props.type = 'Circunferencia';
            else if (e > 0 && e < 1) props.type = 'Elipse';
            else if (e === 1) props.type = 'Parábola';
            else props.type = 'Hipérbola';

            let a, b, c;
            if (e < 1) { a = p / (1 - e*e); c = a * e; b = Math.sqrt(a*a - c*c); } 
            else if (e > 1) { a = p / (e*e - 1); c = a * e; b = Math.sqrt(c*c - a*a); } 
            else { a = Infinity; c = p / 2; b = Infinity; }
            props.a = a; props.b = b; props.c = c;

            const f1 = {x: 0, y: 0};
            if (e === 0) {
                props.foci = [f1];
                props.center = f1;
                props.vertices = [ {x: p, y: 0}, {x: -p, y: 0}, {x: 0, y: p}, {x: 0, y: -p} ];
                props.directrices.push({ text: 'No tiene (radio constante)' });
            } else {
                const r_v1 = p / (1 + e);
                const v1_unrotated = { x: r_v1, y: 0 };
                const v1 = { 
                    x: v1_unrotated.x * Math.cos(theta0Rad) - v1_unrotated.y * Math.sin(theta0Rad),
                    y: v1_unrotated.x * Math.sin(theta0Rad) + v1_unrotated.y * Math.cos(theta0Rad)
                };
                
                const d = p / e;
                const cosT0 = Math.cos(theta0Rad);
                const sinT0 = Math.sin(theta0Rad);
                props.directrices.push({
                    text: `$${cosT0.toFixed(2)}x ${sinT0 >= 0 ? '+' : '-'} ${Math.abs(sinT0).toFixed(2)}y = ${d.toFixed(2)}$`
                });

                if (e === 1) {
                    props.vertices = [v1];
                    props.foci = [f1];
                } else {
                    const r_v2 = p / (1 - e);
                    const v2_unrotated = { x: r_v2, y: 0 };
                     const v2 = { 
                        x: v2_unrotated.x * Math.cos(theta0Rad) - v2_unrotated.y * Math.sin(theta0Rad),
                        y: v2_unrotated.x * Math.sin(theta0Rad) + v2_unrotated.y * Math.cos(theta0Rad)
                    };
                    
                    if (props.type === 'Hipérbola' && !showBothBranches) {
                        props.vertices = [v1];
                    } else {
                        props.vertices = [v1, v2];
                    }
                    
                    const centerToFocusDist = c;
                    const centerSign = e < 1 ? -1 : 1;
                    props.center = { x: centerSign * centerToFocusDist * cosT0, y: centerSign * centerToFocusDist * sinT0 };
                    const f2 = { x: 2 * props.center.x, y: 2 * props.center.y };
                    props.foci = [f1, f2];

                    const d2_val = 2 * (props.center.x * cosT0 + props.center.y * sinT0) - d;
                    props.directrices.push({
                         text: `$${cosT0.toFixed(2)}x ${sinT0 >= 0 ? '+' : '-'} ${Math.abs(sinT0).toFixed(2)}y = ${d2_val.toFixed(2)}$`
                    });

                    if (e > 1) {
                        const angle1 = theta0Rad + Math.atan2(b, a);
                        const angle2 = theta0Rad - Math.atan2(b, a);
                        props.asymptotes = [Math.tan(angle1), Math.tan(angle2)];
                    }
                }
            }

            const cosT = Math.cos(theta0Rad);
            const sinT = Math.sin(theta0Rad);
            props.cartesianEq = {
                A: 1 - e*e * cosT*cosT,
                B: -2 * e*e * sinT * cosT,
                C: 1 - e*e * sinT*sinT,
                D: 2 * p * e * cosT,
                E: 2 * p * e * sinT,
                F: -p*p
            };
            
            const allPoints = [...props.vertices, ...props.foci];
            if (props.center) allPoints.push(props.center);
            let minX = Math.min(...allPoints.map(pt => pt.x).filter(isFinite));
            let maxX = Math.max(...allPoints.map(pt => pt.x).filter(isFinite));
            let minY = Math.min(...allPoints.map(pt => pt.y).filter(isFinite));
            let maxY = Math.max(...allPoints.map(pt => pt.y).filter(isFinite));
            
            if (e > 0 && e < 1) {
                const { x: cx, y: cy } = props.center;
                const dx = Math.sqrt(a*a * cosT*cosT + b*b * sinT*sinT);
                const dy = Math.sqrt(a*a * sinT*sinT + b*b * cosT*cosT);
                minX = Math.min(minX, cx - dx); maxX = Math.max(maxX, cx + dx);
                minY = Math.min(minY, cy - dy); maxY = Math.max(maxY, cy + dy);
            } else if (e > 1) {
                const width = maxX - minX; const height = maxY - minY;
                minX -= width * 1.5; maxX += width * 1.5;
                minY -= height * 1.5; maxY += height * 1.5;
            }

            if (props.type === 'Elipse' || props.type === 'Hipérbola' || props.type === 'Circunferencia') {
                const xRange = isFinite(maxX - minX) ? maxX - minX : 10;
                const yRange = isFinite(maxY - minY) ? maxY - minY : 10;
                
                const xPadding = xRange * 0.2;
                const yPadding = yRange * 0.2;

                const finalMinX = minX - xPadding;
                const finalMaxX = maxX + xPadding;
                const finalMinY = minY - yPadding;
                const finalMaxY = maxY + yPadding;

                const finalXRange = finalMaxX - finalMinX;
                const finalYRange = finalMaxY - finalMinY;
                const maxRange = Math.max(finalXRange, finalYRange);

                const xCenter = (minX + maxX) / 2;
                const yCenter = (minY + maxY) / 2;

                props.boundingBox = {
                    x: [xCenter - maxRange / 2, xCenter + maxRange / 2],
                    y: [yCenter - maxRange / 2, yCenter + maxRange / 2]
                };

            } else { 
                const R_raw = Math.max(Math.abs(minX), Math.abs(maxX), Math.abs(minY), Math.abs(maxY));
                const R_final = (R_raw === 0 || !isFinite(R_raw)) ? 5 : R_raw * 1.5;
                props.boundingBox = { x: [-R_final, R_final], y: [-R_final, R_final] };
            }

            return props;
        }

        function formatNum(num) { return isFinite(num) ? num.toFixed(PRECISION) : '\\infty'; }
        function formatPoint(p) { return p ? `(${formatNum(p.x)}, ${formatNum(p.y)})` : 'N/A'; }
        
        function formatCartesianEquation(eq) {
            const term = (val, label) => {
                if (Math.abs(val) < 1e-9) return '';
                const sign = val > 0 ? '+' : '-';
                const num = Math.abs(val);
                const numStr = num.toFixed(PRECISION);
                if (Math.abs(num - 1.0) < 1e-9 && label) return `${sign} ${label}`;
                return `${sign} ${numStr}${label}`;
            };
            let str = `${term(eq.A, 'x^2')} ${term(eq.B, 'xy')} ${term(eq.C, 'y^2')} ${term(eq.D, 'x')} ${term(eq.E, 'y')} ${term(eq.F, '')} = 0`;
            str = str.trim();
            if (str.startsWith('+')) str = str.substring(2);
            return `$${str}$`;
        }

        function updateInfoPanel(props) {
            let html = `<div class="bg-gray-900/50 rounded-lg p-3 text-center mb-4"><strong class="text-sky-300 text-base">${props.type}</strong></div>`;
            
            html += `<div class="space-y-2">`;
            html += `<p><strong class="font-semibold text-sky-400">Ecuación Cartesiana:</strong><br>${formatCartesianEquation(props.cartesianEq)}</p>`;
            if (props.type !== 'Parábola') {
                html += `<p><strong class="font-semibold text-sky-400">Semieje Mayor (a):</strong> $${formatNum(props.a)}$</p>`;
                html += `<p><strong class="font-semibold text-sky-400">Semieje Menor (b):</strong> $${formatNum(props.b)}$</p>`;
                html += `<p><strong class="font-semibold text-sky-400">Centro:</strong> $${formatPoint(props.center)}$</p>`;
            }
            html += `<p><strong class="font-semibold text-sky-400">Distancia Focal (c):</strong> $${formatNum(props.c)}$</p>`;
            html += `<p><strong class="font-semibold text-sky-400">Vértice(s):</strong> $${props.vertices.map(formatPoint).join(', ')}$</p>`;
            html += `<p><strong class="font-semibold text-sky-400">Foco(s):</strong> $${props.foci.map(formatPoint).join(', ')}$</p>`;
            html += `<p><strong class="font-semibold text-sky-400">Directriz/ces:</strong><br>${props.directrices.map(d => d.text).join('<br>')}</p>`;
            if (props.type === 'Hipérbola' && !showBothBranches) {
                html += `<p class="text-xs text-gray-400 mt-2"><i>Se visualiza una sola rama.</i></p>`;
            }
            html += `</div>`;

            dom.infoPanel.innerHTML = html;
            if (window.MathJax) window.MathJax.typesetPromise([dom.infoPanel]);
        }

        function drawPlot(props) {
            const { e, p, theta0Rad } = props;
            const traces = [];

            if (e > 1) { 
                const N = 1201;
                const theta = Array.from({length: N}, (_, i) => -Math.PI + i * 2 * Math.PI / (N - 1));
                const branch1 = { x: [], y: [] };
                const branch2 = { x: [], y: [] };

                theta.forEach(th_i => {
                    const den = 1 + e * Math.cos(th_i);
                    if (Math.abs(den) < 1e-7) { branch1.x.push(null); branch1.y.push(null); return; }
                    let r = p / den;
                    const thUse = th_i + theta0Rad;
                    if (isFinite(r) && Math.abs(r) < 1e4) {
                        branch1.x.push(r * Math.cos(thUse));
                        branch1.y.push(r * Math.sin(thUse));
                    } else {
                        branch1.x.push(null); branch1.y.push(null);
                    }
                });

                traces.push({
                    x: branch1.x, y: branch1.y, mode: 'lines',
                    line: { color: state.currentColor, width: 3.5 },
                    name: 'Hipérbola', hoverinfo: 'none'
                });

                if (showBothBranches) {
                    theta.forEach(th_i => {
                        const den = 1 - e * Math.cos(th_i);
                        if (Math.abs(den) < 1e-7) { branch2.x.push(null); branch2.y.push(null); return; }
                        let r = p / den;
                        const thUse = th_i + theta0Rad;
                        if (isFinite(r) && Math.abs(r) < 1e4) {
                            branch2.x.push(r * Math.cos(thUse));
                            branch2.y.push(r * Math.sin(thUse));
                        } else {
                            branch2.x.push(null); branch2.y.push(null);
                        }
                    });

                    traces.push({
                        x: branch2.x, y: branch2.y, mode: 'lines',
                        line: { color: state.currentColor, width: 3.5 },
                        showlegend: false, hoverinfo: 'none'
                    });
                }
            } else { 
                const N = 1001;
                const theta = Array.from({length: N}, (_, i) => -2 * Math.PI + i * 4 * Math.PI / (N - 1));
                const x = [], y = [];
                for (const th of theta) {
                    const den = 1 + e * Math.cos(th - theta0Rad);
                    if (Math.abs(den) < 1e-9) { x.push(null); y.push(null); continue; }
                    const r = p / den;
                    if (!isFinite(r) || Math.abs(r) > 1e4) {
                        x.push(null); y.push(null); continue;
                    }
                    x.push(r * Math.cos(th));
                    y.push(r * Math.sin(th));
                }
                traces.push({ 
                    x, y, mode: 'lines', name: 'Cónica', 
                    line: { color: state.currentColor, width: 3.5 }, 
                    hoverinfo: 'none' 
                });
            }

            if (props.asymptotes.length > 0) {
                const [m1, m2] = props.asymptotes;
                const { center } = props;
                const R = Math.max(...props.boundingBox.x.map(Math.abs));

                const asymptoteStyle = {
                    color: state.asymptoteColor,
                    width: 2,
                    dash: 'dash',
                    simplify: false
                };
                
                traces.push({
                    x: [center.x - R, center.x + R],
                    y: [center.y + m1 * (-R), center.y + m1 * R],
                    mode: 'lines', name: 'Asíntotas', line: asymptoteStyle, hoverinfo: 'none'
                });
                traces.push({
                    x: [center.x - R, center.x + R],
                    y: [center.y + m2 * (-R), center.y + m2 * R],
                    mode: 'lines', line: asymptoteStyle, showlegend: false, hoverinfo: 'none'
                });
            }

            traces.push({ x: props.foci.map(f => f.x), y: props.foci.map(f => f.y), mode: 'markers+text', name: 'Focos', marker: { color: '#ef4444', size: 10, symbol: 'circle', line: { color: '#111827', width: 2 } }, text: props.foci.map((f, i) => `F${i+1}`), textposition: 'top right', textfont: {color: '#ef4444'}, hoverinfo: 'none' });
            traces.push({ x: props.vertices.map(v => v.x), y: props.vertices.map(v => v.y), mode: 'markers+text', name: 'Vértices', marker: { color: '#60a5fa', size: 9, symbol: 'circle' }, text: props.vertices.map((v, i) => `V${i+1}`), textposition: 'bottom left', textfont: {color: '#60a5fa'}, hoverinfo: 'none' });
            
            if (props.center) {
                traces.push({ x: [props.center.x], y: [props.center.y], mode: 'markers+text', name: 'Centro', marker: { color: '#f59e0b', size: 9, symbol: 'diamond' }, text: ['C'], textposition: 'top center', textfont: {color: '#f59e0b'}, hoverinfo: 'none' });
            }

            const layout = {
                paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
                margin: { l: 50, r: 20, t: 20, b: 50 },
                xaxis: {
                    title: { text: 'x', font: { color: '#FFFFFF' } },
                    zeroline: true, zerolinecolor: '#9ca3af', zerolinewidth: 1,
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    scaleanchor: 'y', scaleratio: 1,
                    range: props.boundingBox.x,
                    color: '#FFFFFF',
                    tickfont: { color: '#FFFFFF' }
                },
                yaxis: {
                    title: { text: 'y', font: { color: '#FFFFFF' } },
                    zeroline: true, zerolinecolor: '#9ca3af', zerolinewidth: 1,
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    range: props.boundingBox.y,
                    color: '#FFFFFF',
                    tickfont: { color: '#FFFFFF' }
                },
                showlegend: false, dragmode: 'pan', hovermode: false,
                transition: { duration: 50, easing: 'cubic-in-out' }
            };

            const config = { responsive: true, scrollZoom: true, displaylogo: false, modeBarButtonsToRemove: ['select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'toImage'] };

            Plotly.react(dom.plotContainer, traces, layout, config);
        }
        
        function init3D() {
            if (three.renderer) return;
            const width = dom.threeContainer.clientWidth;
            const height = dom.threeContainer.clientHeight;

            three.scene = new THREE.Scene();
            three.camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
            three.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            three.renderer.setSize(width, height);
            three.renderer.setPixelRatio(window.devicePixelRatio);
            dom.threeContainer.appendChild(three.renderer.domElement);

            three.controls = new OrbitControls(three.camera, three.renderer.domElement);
            three.controls.enableDamping = true;
            three.controls.autoRotate = true;
            three.controls.autoRotateSpeed = 0.5;

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
            hemiLight.position.set(0, 20, 0);
            three.scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(8, 12, 15);
            three.scene.add(dirLight);

            const animate = () => {
                three.animationFrameId = requestAnimationFrame(animate);
                three.controls.update();
                three.renderer.render(three.scene, three.camera);
            };
            animate();
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            if (!three.renderer) return;
            const width = dom.threeContainer.clientWidth;
            const height = dom.threeContainer.clientHeight;
            three.camera.aspect = width / height;
            three.camera.updateProjectionMatrix();
            three.renderer.setSize(width, height);
        }

        function draw3DScene(props) {
            init3D();
            three.meshes.forEach(m => three.scene.remove(m));
            three.meshes = [];
            
            const { e, p, theta0Rad } = props;

            const solidMat = new THREE.MeshStandardMaterial({
                color: state.currentColor, metalness: 0.2, roughness: 0.5,
                transparent: true, opacity: 0.8, side: THREE.DoubleSide,
                polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1
            });
            const wireMat = new THREE.MeshBasicMaterial({
                color: '#FFFFFF', wireframe: true, transparent: true, opacity: 0.25
            });
            
            const makeLathe = (points) => {
                if (points.length < 2) return null;
                const geom = new THREE.LatheGeometry(points, 96);
                geom.center();
                const solid = new THREE.Mesh(geom, solidMat);
                const wire  = new THREE.Mesh(geom.clone(), wireMat);
                const grp   = new THREE.Group();
                grp.add(solid, wire);
                grp.rotation.z = -theta0Rad;
                return grp;
            };

            if (e > 1) {
                const N = 200;
                const buildBranch = (sign) => {
                    const pts = [];
                    const θlim = Math.acos(-1 / e) - 1e-4;
                    for (let i = 0; i <= N; i++) {
                        const θ = -θlim + (2 * θlim * i / N);
                        const r = p / (1 + sign * e * Math.cos(θ));
                        if (r > 0 && isFinite(r) && r < 5e3) {
                            pts.push(new THREE.Vector2(r * Math.sin(θ), r * Math.cos(θ)));
                        }
                    }
                    return pts;
                };

                const branch1Pts = buildBranch(1);
                const g1 = makeLathe(branch1Pts);
                if (g1) { three.scene.add(g1); three.meshes.push(g1); }

                if (showBothBranches) {
                    const branch2Pts = buildBranch(-1);
                    const g2 = makeLathe(branch2Pts);
                    if (g2) { 
                        g2.rotation.z += Math.PI;
                        three.scene.add(g2); 
                        three.meshes.push(g2); 
                    }
                }
            } else { 
                const points = [];
                const N = 200;
                const theta = Array.from({length: N}, (_, i) => -Math.PI + i * 2 * Math.PI / (N - 1));
                for (const th of theta) {
                     const r = p / (1 + e * Math.cos(th));
                     if(isFinite(r) && r > 0 && r < 50) {
                         points.push(new THREE.Vector2(r * Math.sin(th), r * Math.cos(th)));
                     }
                }
                const g = makeLathe(points);
                if (g) {
                    three.scene.add(g);
                    three.meshes.push(g);
                }
            }

            const fitCameraToScene = () => {
                const box = new THREE.Box3();
                three.meshes.forEach(m => box.expandByObject(m));
                if (box.isEmpty()) {
                    three.camera.position.set(0, 0, 10);
                    three.controls.target.set(0,0,0);
                    return;
                };

                const center = new THREE.Vector3();
                const size = new THREE.Vector3();
                box.getCenter(center);
                box.getSize(size);
                
                const fov = three.camera.fov * (Math.PI / 180);
                const sizeLength = size.length();
                let dist = sizeLength / (2 * Math.tan(fov / 2));
                dist *= 1.2;
                
                three.camera.position.copy(center).add(new THREE.Vector3(0, 0, dist));
                three.camera.near = dist / 100;
                three.camera.far = dist * 100;
                three.camera.updateProjectionMatrix();

                three.controls.target.copy(center);
                three.controls.update();
            }
            fitCameraToScene();
        }

        function toggle3DView(show) {
            state.show3D = show;
            dom.viewToggle.textContent = show ? '2D' : '3D';
            if (show) {
                dom.plotContainer.classList.add('opacity-0');
                dom.threeContainer.classList.remove('opacity-0', 'pointer-events-none');
                mainUpdateCycle();
            } else {
                dom.plotContainer.classList.remove('opacity-0');
                dom.threeContainer.classList.add('opacity-0', 'pointer-events-none');
                dom.controls3D.classList.add('opacity-0', 'pointer-events-none');
            }
        }

        function update3DDisplay(mode) {
            const btnActive = 'bg-sky-500/50';
            const btnInactive = 'bg-sky-500/20';
            dom.solidBtn.classList.remove(btnActive, btnInactive);
            dom.wireframeBtn.classList.remove(btnActive, btnInactive);
            dom.bothBtn.classList.remove(btnActive, btnInactive);

            dom.solidBtn.classList.add(mode === 'solid' ? btnActive : btnInactive);
            dom.wireframeBtn.classList.add(mode === 'wireframe' ? btnActive : btnInactive);
            dom.bothBtn.classList.add(mode === 'both' ? btnActive : btnInactive);
            
            three.meshes.forEach(group => {
                const solidMesh = group.children[0];
                const wireMesh = group.children[1];
                if (solidMesh) solidMesh.visible = (mode === 'solid' || mode === 'both');
                if (wireMesh) wireMesh.visible = (mode === 'wireframe' || mode === 'both');
            });
        }

        function mainUpdateCycle() {
            state.e = parseFloat(dom.eSlider.value);
            state.p = parseFloat(dom.pSlider.value);
            state.theta0 = parseInt(dom.theta0Select.value);
            
            dom.eValueDisplay.textContent = state.e.toFixed(2);
            dom.pValueDisplay.textContent = state.p.toFixed(1);

            const props = calculateConicProperties();
            updateInfoPanel(props);

            if (props.type === 'Hipérbola') {
                dom.asymptotePaletteToggle.classList.remove('hidden');
                dom.branchToggleContainer.classList.remove('hidden');
            } else {
                dom.asymptotePaletteToggle.classList.add('hidden');
                dom.branchToggleContainer.classList.add('hidden');
                dom.asymptotePaletteWidget.classList.add('opacity-0', 'pointer-events-none', 'scale-95', '-translate-y-2');
            }
            
            if (state.show3D) {
                draw3DScene(props);
                update3DDisplay('both');
            }
            else drawPlot(props);
        }

        function setupEventListeners() {
            [dom.eSlider, dom.pSlider, dom.theta0Select].forEach(el => el.addEventListener('input', mainUpdateCycle));
            dom.viewToggle.addEventListener('click', () => toggle3DView(!state.show3D));
            dom.homeButton.addEventListener('click', () => {
                mainUpdateCycle();
            });

            dom.branchToggle.checked = showBothBranches;
            dom.branchToggle.addEventListener('change', e => {
               showBothBranches = e.target.checked;
               mainUpdateCycle();
            });

            dom.solidBtn.addEventListener('click', () => update3DDisplay('solid'));
            dom.wireframeBtn.addEventListener('click', () => update3DDisplay('wireframe'));
            dom.bothBtn.addEventListener('click', () => update3DDisplay('both'));
            
            const closeAllPalettes = () => {
                dom.paletteWidget.classList.add('opacity-0', 'pointer-events-none', 'scale-95', '-translate-y-2');
                dom.asymptotePaletteWidget.classList.add('opacity-0', 'pointer-events-none', 'scale-95', '-translate-y-2');
            };

            const togglePalette = (widget) => {
                const isOpening = widget.classList.contains('opacity-0');
                closeAllPalettes();
                if (isOpening) {
                    widget.classList.remove('opacity-0', 'pointer-events-none', 'scale-95', '-translate-y-2');
                }
            };

            dom.paletteToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                togglePalette(dom.paletteWidget);
            });

            dom.asymptotePaletteToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                togglePalette(dom.asymptotePaletteWidget);
            });

            document.addEventListener('click', closeAllPalettes);
            dom.paletteWidget.addEventListener('click', e => e.stopPropagation());
            dom.asymptotePaletteWidget.addEventListener('click', e => e.stopPropagation());

            const createSwatch = (color, targetStateProperty) => {
                const swatch = document.createElement('button');
                swatch.className = 'w-7 h-7 rounded-full transition-transform duration-200 hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-white';
                swatch.style.backgroundColor = color;
                swatch.addEventListener('click', () => {
                    state[targetStateProperty] = color;
                    if (targetStateProperty === 'currentColor') {
                        three.meshes.forEach(group => {
                            const solidMesh = group.children[0];
                            if (solidMesh) solidMesh.material.color.set(color);
                        });
                    }
                    mainUpdateCycle();
                    closeAllPalettes();
                });
                return swatch;
            };

            dom.colorSwatchesContainer.innerHTML = '';
            conicColors.forEach(color => {
                dom.colorSwatchesContainer.appendChild(createSwatch(color, 'currentColor'));
            });
            
            dom.asymptoteColorSwatchesContainer.innerHTML = '';
            asymptoteColors.forEach(color => {
                dom.asymptoteColorSwatchesContainer.appendChild(createSwatch(color, 'asymptoteColor'));
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            mainUpdateCycle();
        });

    </script>
</body>
</html>
