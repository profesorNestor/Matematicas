<!DOCTYPE html>
<html lang="es" class="dark">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simulador de Secciones Cónicas | Néstor Montoya & Gemini AI</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js" charset="utf-8"></script>
    
    <!-- Three.js & OrbitControls -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <!-- MathJax -->
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-color: #111827; /* gray-900 */
            --card-bg: rgba(31, 41, 55, 0.5); /* gray-800 with alpha */
            --card-border: rgba(255, 255, 255, 0.1);
            --neumorph-bg: #1f2937; /* gray-800 */
            --neumorph-shadow-light: rgba(255, 255, 255, 0.05);
            --neumorph-shadow-dark: rgba(0, 0, 0, 0.5);
            --primary-accent: #38bdf8; /* sky-400 */
            --text-light: #f3f4f6; /* gray-100 */
            --text-dark: #9ca3af; /* gray-400 */
        }

        html { scroll-behavior: smooth; }

        /* Ensure vertical scroll on small screens */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            min-height: 100vh;
        }

        .glassmorphism {
            background: var(--card-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--card-border);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .neumorph-inset {
            background: var(--neumorph-bg);
            box-shadow: inset 6px 6px 12px var(--neumorph-shadow-dark), inset -6px -6px 12px var(--neumorph-shadow-light);
        }

        /* Custom Slider */
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 8px;
            background: var(--neumorph-bg);
            border-radius: 8px;
            box-shadow: inset 3px 3px 6px var(--neumorph-shadow-dark), inset -3px -3px 6px var(--neumorph-shadow-light);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 24px; height: 24px;
            background: var(--primary-accent);
            border-radius: 50%; cursor: grab;
            box-shadow: 4px 4px 8px var(--neumorph-shadow-dark), -4px -4px 8px var(--neumorph-shadow-light);
            transition: transform 0.2s ease;
        }
        input[type="range"]:active::-webkit-slider-thumb {
            cursor: grabbing;
            transform: scale(1.1);
        }
        
        /* Custom Scrollbar for Info Panel */
        #info-panel::-webkit-scrollbar { width: 8px; height: 8px; }
        #info-panel::-webkit-scrollbar-track { background: var(--neumorph-bg); border-radius: 10px; }
        #info-panel::-webkit-scrollbar-thumb { background-color: var(--primary-accent); border-radius: 10px; border: 2px solid var(--neumorph-bg); }
    </style>
</head>

<body class="min-h-screen">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-5xl font-extrabold tracking-tight text-transparent bg-clip-text bg-gradient-to-r from-sky-400 to-cyan-300">
                Simulador de Secciones Cónicas
            </h1>
            <p id="main-equation" class="mt-3 text-lg text-gray-400">$r(\theta) = \frac{p}{1 + e \cdot \cos(\theta - \theta_0)}$</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-5 gap-8">
            
            <!-- Left Panel: Controls & Data -->
            <div class="lg:col-span-2 flex flex-col gap-8">
                
                <div class="glassmorphism rounded-2xl p-6">
                    <h2 class="text-xl font-bold text-sky-400 mb-6">Parámetros Geométricos</h2>
                    <div class="space-y-6">
                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <label for="e" class="font-medium text-sm whitespace-nowrap">Excentricidad ($e$)</label>
                                <span id="e-value-display" class="font-mono text-sm bg-gray-900/50 text-sky-300 py-1 px-3 rounded-full ml-4">0.50</span>
                            </div>
                            <input id="e" type="range" min="0" max="2" step="0.01" value="0.5">
                        </div>
                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <label for="p" class="font-medium text-sm whitespace-nowrap">Semilatus Rectum ($p$)</label>
                                <span id="p-value-display" class="font-mono text-sm bg-gray-900/50 text-sky-300 py-1 px-3 rounded-full ml-4">1.5</span>
                            </div>
                            <input id="p" type="range" min="0.1" max="10" step="0.1" value="1.5">
                        </div>
                        <div>
                            <label for="theta0" class="font-medium text-sm mb-2 block">Orientación ($\theta_0$)</label>
                            <select id="theta0" class="w-full neumorph-inset p-3 text-sm rounded-lg focus:ring-2 focus:ring-sky-400 focus:outline-none appearance-none">
                                <option value="0">Vertical, apertura izquierda</option>
                                <option value="180">Vertical, apertura derecha</option>
                                <option value="90">Horizontal, apertura abajo</option>
                                <option value="270">Horizontal, apertura arriba</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="glassmorphism rounded-2xl p-6 flex flex-col">
                     <h2 class="text-xl font-bold text-sky-400 mb-4">Datos Analíticos</h2>
                     <div id="info-panel" class="text-sm space-y-3 text-gray-300 max-h-[450px] overflow-auto pr-2">
                         <!-- Dynamic content here -->
                     </div>
                </div>

            </div>

            <!-- Right Panel: Visualization -->
            <div class="lg:col-span-3 min-h-[60vh] lg:min-h-0 neumorph-inset rounded-2xl p-2 relative">
                <div id="plot-container" class="w-full h-full rounded-xl overflow-hidden"></div>
                <div id="three-d-container" class="w-full h-full absolute top-0 left-0 rounded-xl overflow-hidden pointer-events-none opacity-0 transition-opacity duration-500"></div>

                <!-- 2D/3D Controls -->
                <div class="absolute top-4 right-4 z-20 flex items-center gap-2 p-2 rounded-full glassmorphism">
                    <button id="palette-toggle" aria-label="Cambiar color" class="p-2 rounded-full hover:bg-gray-700/50 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path><path d="m12 13.01 3.5-3.5a2.12 2.12 0 1 0-3-3L12 7.01"></path></svg>
                    </button>
                    <button id="view-toggle" aria-label="Cambiar vista" class="p-2 w-10 h-10 flex items-center justify-center rounded-full hover:bg-gray-700/50 transition-colors font-bold text-sm">3D</button>
                    <button id="home-button" aria-label="Reiniciar vista" class="p-2 rounded-full hover:bg-gray-700/50 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
                    </button>
                </div>

                <!-- Color Palette Widget -->
                <div id="color-palette-widget" class="absolute top-20 right-4 z-20 p-4 rounded-2xl glassmorphism opacity-0 pointer-events-none transition-all duration-300 transform scale-95 -translate-y-2">
                    <p class="text-sm font-bold text-center mb-3">Color de la Curva</p>
                    <div id="color-swatches" class="grid grid-cols-5 gap-3">
                        <!-- Color swatches will be injected here by JS -->
                    </div>
                </div>
                
                <!-- 3D Specific Controls -->
                <div id="controls-3d" class="absolute bottom-4 left-1/2 -translate-x-1/2 z-20 flex items-center gap-2 p-2 rounded-full glassmorphism opacity-0 pointer-events-none transition-opacity">
                    <button id="solid-btn" class="px-3 py-1 text-xs rounded-full bg-sky-500/20">Sólido</button>
                    <button id="wireframe-btn" class="px-3 py-1 text-xs rounded-full bg-sky-500/20">Malla</button>
                    <button id="both-btn" class="px-3 py-1 text-xs rounded-full bg-sky-500/50">Ambos</button>
                </div>

            </div>
        </main>
        
        <footer class="text-center text-gray-500 text-sm mt-12 pb-4">
            Autor: Msc Néstor Fabio Montoya Palacios & Gemini AI
        </footer>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        /* 1. CONFIG & DOM ELEMENTS */
        const $ = (selector) => document.querySelector(selector);
        
        const dom = {
            eSlider: $('#e'), pSlider: $('#p'), theta0Select: $('#theta0'),
            eValueDisplay: $('#e-value-display'), pValueDisplay: $('#p-value-display'),
            infoPanel: $('#info-panel'), plotContainer: $('#plot-container'),
            threeContainer: $('#three-d-container'), viewToggle: $('#view-toggle'),
            homeButton: $('#home-button'),
            controls3D: $('#controls-3d'), solidBtn: $('#solid-btn'),
            wireframeBtn: $('#wireframe-btn'), bothBtn: $('#both-btn'),
            paletteToggle: $('#palette-toggle'),
            paletteWidget: $('#color-palette-widget'),
            colorSwatchesContainer: $('#color-swatches'),
        };

        const RAD = Math.PI / 180;
        const PRECISION = 2;
        const conicColors = ['#38bdf8', '#fb7185', '#4ade80', '#facc15', '#a78bfa', '#f472b6', '#2dd4bf', '#f87171', '#c084fc', '#fbbf24'];

        let state = { e: 0.5, p: 1.5, theta0: 0, show3D: false, currentColor: conicColors[0] };
        let three = { scene: null, camera: null, renderer: null, solidMesh: null, wireMesh: null, controls: null, animationFrameId: null };

        /* 2. MATHEMATICAL CALCULATIONS */
        function calculateConicProperties() {
            const { e, p } = state;
            const theta0Deg = state.theta0;
            const theta0Rad = theta0Deg * RAD;
            
            let props = { e, p, theta0Rad, type: '', vertices: [], foci: [], center: null, asymptotes: [], directrices: [], cartesianEq: {}, boundingBox: {} };

            if (e === 0) props.type = 'Circunferencia';
            else if (e > 0 && e < 1) props.type = 'Elipse';
            else if (e === 1) props.type = 'Parábola';
            else props.type = 'Hipérbola';

            let a, b, c;
            if (e < 1) { a = p / (1 - e*e); c = a * e; b = Math.sqrt(a*a - c*c); } 
            else if (e > 1) { a = p / (e*e - 1); c = a * e; b = Math.sqrt(c*c - a*a); } 
            else { a = Infinity; c = p / 2; b = Infinity; }
            props.a = a; props.b = b; props.c = c;

            const f1 = {x: 0, y: 0};
            if (e === 0) {
                props.foci = [f1];
                props.center = f1;
                props.vertices = [ {x: p, y: 0}, {x: -p, y: 0}, {x: 0, y: p}, {x: 0, y: -p} ];
                props.directrices.push({ text: 'No tiene (radio constante)' });
            } else {
                const r_v1 = p / (1 + e);
                const v1 = { x: r_v1 * Math.cos(theta0Rad), y: r_v1 * Math.sin(theta0Rad) };
                
                const d = p / e;
                const cosT0 = Math.cos(theta0Rad);
                const sinT0 = Math.sin(theta0Rad);
                props.directrices.push({
                    text: `$${cosT0.toFixed(2)}x ${sinT0 >= 0 ? '+' : '-'} ${Math.abs(sinT0).toFixed(2)}y = ${d.toFixed(2)}$`
                });

                if (e === 1) {
                    props.vertices = [v1];
                    props.foci = [f1];
                } else {
                    const r_v2 = p / (1 - e);
                    const v2 = { x: r_v2 * Math.cos(theta0Rad + Math.PI), y: r_v2 * Math.sin(theta0Rad + Math.PI) };
                    props.vertices = [v1, v2];
                    
                    const centerToFocusDist = c;
                    const centerSign = e < 1 ? -1 : 1;
                    props.center = { x: centerSign * centerToFocusDist * cosT0, y: centerSign * centerToFocusDist * sinT0 };
                    const f2 = { x: 2 * props.center.x, y: 2 * props.center.y };
                    props.foci = [f1, f2];

                    const d2_val = 2 * (props.center.x * cosT0 + props.center.y * sinT0) - d;
                    props.directrices.push({
                         text: `$${cosT0.toFixed(2)}x ${sinT0 >= 0 ? '+' : '-'} ${Math.abs(sinT0).toFixed(2)}y = ${d2_val.toFixed(2)}$`
                    });

                    if (e > 1) {
                        const angle1 = theta0Rad + Math.atan2(b, a);
                        const angle2 = theta0Rad - Math.atan2(b, a);
                        props.asymptotes = [Math.tan(angle1), Math.tan(angle2)];
                    }
                }
            }

            const cosT = Math.cos(theta0Rad);
            const sinT = Math.sin(theta0Rad);
            props.cartesianEq = {
                A: 1 - e*e * cosT*cosT,
                B: -2 * e*e * sinT * cosT,
                C: 1 - e*e * sinT*sinT,
                D: 2 * p * e * cosT,
                E: 2 * p * e * sinT,
                F: -p*p
            };

            const allPoints = [...props.vertices, ...props.foci];
            if (props.center) allPoints.push(props.center);
            let minX = Math.min(...allPoints.map(pt => pt.x));
            let maxX = Math.max(...allPoints.map(pt => pt.x));
            let minY = Math.min(...allPoints.map(pt => pt.y));
            let maxY = Math.max(...allPoints.map(pt => pt.y));
            
            if (e > 0 && e < 1) {
                const { x: cx, y: cy } = props.center;
                const dx = Math.sqrt(a*a * cosT*cosT + b*b * sinT*sinT);
                const dy = Math.sqrt(a*a * sinT*sinT + b*b * cosT*cosT);
                minX = Math.min(minX, cx - dx); maxX = Math.max(maxX, cx + dx);
                minY = Math.min(minY, cy - dy); maxY = Math.max(maxY, cy + dy);
            } else if (e > 1) {
                const width = maxX - minX; const height = maxY - minY;
                minX -= width * 0.5; maxX += width * 0.5;
                minY -= height * 0.5; maxY += height * 0.5;
            }

            const R_raw = Math.max(Math.abs(minX), Math.abs(maxX), Math.abs(minY), Math.abs(maxY));
            const R_final = (R_raw === 0 || !isFinite(R_raw)) ? 5 : R_raw * 1.2;
            props.boundingBox = { x: [-R_final, R_final], y: [-R_final, R_final] };

            return props;
        }

        /* 3. UI & INFO PANEL UPDATE */
        function formatNum(num) { return isFinite(num) ? num.toFixed(PRECISION) : '\\infty'; }
        function formatPoint(p) { return p ? `(${formatNum(p.x)}, ${formatNum(p.y)})` : 'N/A'; }
        
        function formatCartesianEquation(eq) {
            const term = (val, label) => {
                if (Math.abs(val) < 1e-9) return '';
                const sign = val > 0 ? '+' : '-';
                const num = Math.abs(val);
                const numStr = num.toFixed(PRECISION);
                if (Math.abs(num - 1.0) < 1e-9 && label) return `${sign} ${label}`;
                return `${sign} ${numStr}${label}`;
            };
            let str = `${term(eq.A, 'x^2')} ${term(eq.B, 'xy')} ${term(eq.C, 'y^2')} ${term(eq.D, 'x')} ${term(eq.E, 'y')} ${term(eq.F, '')} = 0`;
            str = str.trim();
            if (str.startsWith('+')) str = str.substring(2);
            return `$${str}$`;
        }

        function updateInfoPanel(props) {
            let html = `<div class="bg-gray-900/50 rounded-lg p-3 text-center mb-4"><strong class="text-sky-300 text-base">${props.type}</strong></div>`;
            
            html += `<div class="space-y-2">`;
            html += `<p><strong class="font-semibold text-sky-400">Ecuación Cartesiana:</strong><br>${formatCartesianEquation(props.cartesianEq)}</p>`;
            if (props.type !== 'Parábola') {
                html += `<p><strong class="font-semibold text-sky-400">Semieje Mayor (a):</strong> $${formatNum(props.a)}$</p>`;
                html += `<p><strong class="font-semibold text-sky-400">Semieje Menor (b):</strong> $${formatNum(props.b)}$</p>`;
                html += `<p><strong class="font-semibold text-sky-400">Centro:</strong> $${formatPoint(props.center)}$</p>`;
            }
            html += `<p><strong class="font-semibold text-sky-400">Distancia Focal (c):</strong> $${formatNum(props.c)}$</p>`;
            html += `<p><strong class="font-semibold text-sky-400">Vértice(s):</strong> $${props.vertices.map(formatPoint).join(', ')}$</p>`;
            html += `<p><strong class="font-semibold text-sky-400">Foco(s):</strong> $${props.foci.map(formatPoint).join(', ')}$</p>`;
            html += `<p><strong class="font-semibold text-sky-400">Directriz/ces:</strong><br>${props.directrices.map(d => d.text).join('<br>')}</p>`;
            html += `</div>`;

            dom.infoPanel.innerHTML = html;
            if (window.MathJax) window.MathJax.typesetPromise([dom.infoPanel]);
        }


        /* 4. PLOTLY 2D VISUALIZATION */
        function drawPlot(props) {
            const { e, p, theta0Rad } = props;
            const N = 1001;
            const theta = Array.from({length: N}, (_, i) => -2 * Math.PI + i * 4 * Math.PI / (N - 1));
            
            const x = [], y = [];
            for (const th of theta) {
                const den = 1 + e * Math.cos(th - theta0Rad);
                if (Math.abs(den) < 1e-9) { x.push(null); y.push(null); continue; }
                const r = p / den;
                if (!isFinite(r) || Math.abs(r) > 1e4) { x.push(null); y.push(null); continue; }
                x.push(r * Math.cos(th));
                y.push(r * Math.sin(th));
            }

            const traces = [
                { x, y, mode: 'lines', name: 'Cónica', line: { color: state.currentColor, width: 3.5 }, hoverinfo: 'none' },
                { x: props.foci.map(f => f.x), y: props.foci.map(f => f.y), mode: 'markers+text', name: 'Focos', marker: { color: '#ef4444', size: 10, symbol: 'circle', line: { color: '#111827', width: 2 } }, text: props.foci.map((f, i) => `F${i+1}`), textposition: 'top right', textfont: {color: '#ef4444'}, hoverinfo: 'none' },
                { x: props.vertices.map(v => v.x), y: props.vertices.map(v => v.y), mode: 'markers+text', name: 'Vértices', marker: { color: '#60a5fa', size: 9, symbol: 'circle' }, text: props.vertices.map((v, i) => `V${i+1}`), textposition: 'bottom left', textfont: {color: '#60a5fa'}, hoverinfo: 'none' },
            ];
            
            if (props.center) {
                traces.push({ x: [props.center.x], y: [props.center.y], mode: 'markers+text', name: 'Centro', marker: { color: '#f59e0b', size: 9, symbol: 'diamond' }, text: ['C'], textposition: 'top center', textfont: {color: '#f59e0b'}, hoverinfo: 'none' });
            }

            if (props.asymptotes.length > 0) {
                const [m1, m2] = props.asymptotes;
                const { center } = props;
                const rangeX = props.boundingBox.x[1];
                traces.push({
                    x: [center.x - rangeX, center.x + rangeX],
                    y: [center.y + m1 * ( -rangeX), center.y + m1 * (rangeX)],
                    mode: 'lines', name: 'Asíntota', line: { color: '#f472b6', width: 2, dash: 'dot' }, hoverinfo: 'none'
                });
                traces.push({
                    x: [center.x - rangeX, center.x + rangeX],
                    y: [center.y + m2 * (-rangeX), center.y + m2 * (rangeX)],
                    mode: 'lines', name: 'Asíntota', line: { color: '#f472b6', width: 2, dash: 'dot' }, hoverinfo: 'none'
                });
            }

            const layout = {
                paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
                margin: { l: 50, r: 20, t: 20, b: 50 },
                xaxis: {
                    title: { text: 'x', font: { color: '#FFFFFF' } },
                    zeroline: true, zerolinecolor: '#9ca3af', zerolinewidth: 1,
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    scaleanchor: 'y', scaleratio: 1,
                    range: props.boundingBox.x,
                    color: '#FFFFFF',
                    tickfont: { color: '#FFFFFF' }
                },
                yaxis: {
                    title: { text: 'y', font: { color: '#FFFFFF' } },
                    zeroline: true, zerolinecolor: '#9ca3af', zerolinewidth: 1,
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    range: props.boundingBox.y,
                    color: '#FFFFFF',
                    tickfont: { color: '#FFFFFF' }
                },
                showlegend: false, dragmode: 'pan', hovermode: false,
                transition: { duration: 300, easing: 'cubic-in-out' }
            };

            const config = { responsive: true, scrollZoom: true, displaylogo: false, modeBarButtonsToRemove: ['select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'toImage'] };

            Plotly.react(dom.plotContainer, traces, layout, config);
        }
        
        /* 5. 3D VISUALIZATION */
        function init3D() {
            if (three.renderer) return;
            const width = dom.threeContainer.clientWidth;
            const height = dom.threeContainer.clientHeight;

            three.scene = new THREE.Scene();
            three.camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
            three.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            three.renderer.setSize(width, height);
            three.renderer.setPixelRatio(window.devicePixelRatio);
            dom.threeContainer.appendChild(three.renderer.domElement);

            three.controls = new OrbitControls(three.camera, three.renderer.domElement);
            three.controls.enableDamping = true;
            three.controls.autoRotate = true;
            three.controls.autoRotateSpeed = 0.5;

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
            hemiLight.position.set(0, 20, 0);
            three.scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(8, 12, 15);
            three.scene.add(dirLight);

            const animate = () => {
                three.animationFrameId = requestAnimationFrame(animate);
                three.controls.update();
                three.renderer.render(three.scene, three.camera);
            };
            animate();
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            if (!three.renderer) return;
            const width = dom.threeContainer.clientWidth;
            const height = dom.threeContainer.clientHeight;
            three.camera.aspect = width / height;
            three.camera.updateProjectionMatrix();
            three.renderer.setSize(width, height);
        }

        function draw3DScene(props) {
            init3D();
            if (three.solidMesh) three.scene.remove(three.solidMesh);
            if (three.wireMesh) three.scene.remove(three.wireMesh);
            
            if (props.e === 1 || props.e === 0) return;

            const { e, p, theta0Rad } = props;
            const points = [];
            const N = 100;
            
            let startTheta, endTheta;
            if (props.e > 1) {
                const angleLimit = Math.acos(-1 / e);
                startTheta = -angleLimit + 1e-4;
                endTheta = angleLimit - 1e-4;
            } else {
                startTheta = -Math.PI;
                endTheta = Math.PI;
            }

            for (let i = 0; i <= N; i++) {
                const th = startTheta + (endTheta - startTheta) * i / N;
                const r = p / (1 + e * Math.cos(th));
                if (isFinite(r) && Math.abs(r) < 50) {
                    points.push(new THREE.Vector2(r * Math.sin(th), r * Math.cos(th)));
                }
            }

            if (points.length < 2) return;

            const geometry = new THREE.LatheGeometry(points, 64);
            geometry.center();
            
            const solidMaterial = new THREE.MeshStandardMaterial({
                color: state.currentColor, metalness: 0.2, roughness: 0.5,
                transparent: true, opacity: 0.8, side: THREE.DoubleSide,
                polygonOffset: true,
                polygonOffsetFactor: 1,
                polygonOffsetUnits: 1
            });
            three.solidMesh = new THREE.Mesh(geometry, solidMaterial);
            
            const wireMaterial = new THREE.MeshBasicMaterial({
                color: '#FFFFFF', wireframe: true, transparent: true, opacity: 0.25
            });
            three.wireMesh = new THREE.Mesh(geometry, wireMaterial);

            three.solidMesh.rotation.z = -theta0Rad;
            three.wireMesh.rotation.z = -theta0Rad;

            three.scene.add(three.solidMesh);
            three.scene.add(three.wireMesh);

            geometry.computeBoundingSphere();
            const radius = geometry.boundingSphere.radius;
            const camDistance = radius / Math.sin(three.camera.fov * RAD / 2) * 2.0;

            three.camera.position.set(0, 0, camDistance > 0 ? camDistance : 10);
            three.controls.target.set(0, 0, 0);
            three.controls.update();
        }

        /* 6. EVENT HANDLERS & INITIALIZATION */
        function toggle3DView(show) {
            state.show3D = show;
            dom.viewToggle.textContent = show ? '2D' : '3D';
            if (show) {
                dom.plotContainer.classList.add('opacity-0');
                dom.threeContainer.classList.remove('opacity-0', 'pointer-events-none');
                mainUpdateCycle();
            } else {
                dom.plotContainer.classList.remove('opacity-0');
                dom.threeContainer.classList.add('opacity-0', 'pointer-events-none');
                dom.controls3D.classList.add('opacity-0', 'pointer-events-none');
            }
        }

        function update3DDisplay(mode) {
            const btnActive = 'bg-sky-500/50';
            const btnInactive = 'bg-sky-500/20';
            dom.solidBtn.classList.remove(btnActive, btnInactive);
            dom.wireframeBtn.classList.remove(btnActive, btnInactive);
            dom.bothBtn.classList.remove(btnActive, btnInactive);

            dom.solidBtn.classList.add(mode === 'solid' ? btnActive : btnInactive);
            dom.wireframeBtn.classList.add(mode === 'wireframe' ? btnActive : btnInactive);
            dom.bothBtn.classList.add(mode === 'both' ? btnActive : btnInactive);
            
            if (three.solidMesh) three.solidMesh.visible = (mode === 'solid' || mode === 'both');
            if (three.wireMesh) three.wireMesh.visible = (mode === 'wireframe' || mode === 'both');
        }

        function mainUpdateCycle() {
            state.e = parseFloat(dom.eSlider.value);
            state.p = parseFloat(dom.pSlider.value);
            state.theta0 = parseInt(dom.theta0Select.value);
            
            dom.eValueDisplay.textContent = state.e.toFixed(2);
            dom.pValueDisplay.textContent = state.p.toFixed(1);

            const props = calculateConicProperties();
            updateInfoPanel(props);
            
            if (state.show3D) {
                draw3DScene(props);
                update3DDisplay('both');
            }
            else drawPlot(props);
        }

        function setupEventListeners() {
            [dom.eSlider, dom.pSlider, dom.theta0Select].forEach(el => el.addEventListener('input', mainUpdateCycle));
            dom.viewToggle.addEventListener('click', () => toggle3DView(!state.show3D));
            dom.homeButton.addEventListener('click', () => {
                mainUpdateCycle();
            });

            dom.solidBtn.addEventListener('click', () => update3DDisplay('solid'));
            dom.wireframeBtn.addEventListener('click', () => update3DDisplay('wireframe'));
            dom.bothBtn.addEventListener('click', () => update3DDisplay('both'));
            
            // Color Palette Logic
            dom.paletteToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                dom.paletteWidget.classList.toggle('opacity-0');
                dom.paletteWidget.classList.toggle('pointer-events-none');
                dom.paletteWidget.classList.toggle('scale-95');
                dom.paletteWidget.classList.toggle('-translate-y-2');
            });
            document.addEventListener('click', () => {
                dom.paletteWidget.classList.add('opacity-0', 'pointer-events-none', 'scale-95', '-translate-y-2');
            });
            dom.paletteWidget.addEventListener('click', e => e.stopPropagation());

            conicColors.forEach(color => {
                const swatch = document.createElement('button');
                swatch.className = 'w-7 h-7 rounded-full transition-transform duration-200 hover:scale-110 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-white';
                swatch.style.backgroundColor = color;
                swatch.dataset.color = color;
                dom.colorSwatchesContainer.appendChild(swatch);

                swatch.addEventListener('click', () => {
                    state.currentColor = color;
                    Plotly.restyle(dom.plotContainer, { 'line.color': color }, [0]);
                    if (three.solidMesh) {
                        three.solidMesh.material.color.set(color);
                    }
                    // Optional: close palette on selection
                    dom.paletteToggle.click(); 
                });
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            mainUpdateCycle();
        });

    </script>
</body>
</html>
