<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Visualizador de Series de Taylor - Sci-Fi Edition</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg-dark-space: #010413;
            --bg-card: rgba(10, 25, 47, 0.85);
            --bg-glass: rgba(10, 25, 47, 0.6);
            --border-glow: rgba(0, 191, 255, 0.25);
            --border-highlight: rgba(0, 255, 255, 0.8);
            --text-primary: #E0E7FF;
            --text-secondary: #8A99C1;
            --cyan-glow: #00FFFF;
            --magenta-glow: #FF00FF;
            --yellow-accent: #FFD60A;
            --error-color: #ff4757;
            --transition-speed: 0.4s;
        }

        /* --- Estructura Base y Fondo --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            font-family: 'Rajdhani', sans-serif;
            background-color: var(--bg-dark-space);
            color: var(--text-primary);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: relative;
        }

        #app-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab;
        }
        #canvas:active { cursor: grabbing; }

        /* --- Paneles Flotantes y UI --- */
        .floating-panel {
            position: absolute;
            z-index: 10;
            background: var(--bg-card);
            backdrop-filter: blur(15px) saturate(180%);
            border: 1px solid var(--border-glow);
            border-radius: 16px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
            transition: all var(--transition-speed) ease;
        }

        /* --- Panel de Control Principal --- */
        #control-panel {
            top: 20px;
            left: 20px;
            width: 360px;
            padding: 1rem;
            transform: translateX(0);
        }
        #control-panel.collapsed {
            transform: translateX(calc(-100% + 60px));
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem;
        }
        .panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--cyan-glow);
            text-shadow: 0 0 8px var(--cyan-glow);
        }
        .panel-toggle-icon {
            width: 30px;
            height: 30px;
            transition: transform var(--transition-speed) ease;
        }
        #control-panel.collapsed .panel-toggle-icon {
            transform: rotate(180deg);
        }
        .panel-content {
            padding-top: 1rem;
            border-top: 1px solid var(--border-glow);
            transition: opacity 0.3s, visibility 0.3s, max-height 0.4s ease;
            max-height: 1000px; /* Altura para animación */
        }
        #control-panel.collapsed .panel-content {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            max-height: 0;
        }

        /* --- Controles de la UI --- */
        .input-group { margin-bottom: 1rem; }
        .input-label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
        }
        .futuristic-input, .modern-btn {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-glass);
            border: 1px solid var(--border-glow);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            transition: all var(--transition-speed) ease;
            outline: none;
            cursor: pointer;
        }
        .futuristic-input:focus {
            border-color: var(--border-highlight);
            box-shadow: 0 0 10px var(--cyan-glow);
        }
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.5rem;
        }
        .preset-btn {
            padding: 0.5rem;
            background: var(--bg-glass);
            border: 1px solid var(--border-glow);
            color: var(--text-secondary);
        }
        .preset-btn.active {
            background: var(--cyan-glow);
            color: var(--bg-dark-space);
            border-color: var(--cyan-glow);
            font-weight: 700;
        }
        
        /* --- Leyenda --- */
        #legend {
            bottom: 20px;
            right: 20px;
            padding: 0.75rem 1rem;
        }
        .legend-item { display: flex; align-items: center; }
        .legend-item:not(:last-child) { margin-bottom: 0.5rem; }
        .legend-color { width: 20px; height: 4px; margin-right: 8px; border-radius: 2px; }
        #error-legend-item { display: none; }

        /* --- Modals --- */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(1, 4, 19, 0.8);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-speed) ease, visibility 0s var(--transition-speed);
        }
        .modal-backdrop.active {
            opacity: 1;
            visibility: visible;
            transition-delay: 0s;
        }
        .modal-content {
            background: var(--bg-card);
            border: 1px solid var(--border-highlight);
            border-radius: 16px;
            padding: 2rem;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 50px var(--magenta-glow);
            transform: scale(0.95);
            transition: transform var(--transition-speed) ease;
        }
        .modal-backdrop.active .modal-content {
            transform: scale(1);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-shrink: 0;
        }
        .modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--magenta-glow);
        }
        .modal-body {
            overflow: auto;
            padding-right: 1rem;
        }

        .formula-section, .help-section {
            margin-bottom: 1.5rem;
        }
        .formula-content {
            font-size: 1.2rem;
            padding: 1rem;
            background: var(--bg-glass);
            border-radius: 8px;
            overflow-x: auto;
        }
        .help-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: var(--cyan-glow);
            margin-bottom: 1rem;
        }
        .help-section p, .help-section li {
            color: var(--text-secondary);
            line-height: 1.7;
            font-size: 1.1rem;
        }
        .help-section ul {
            list-style-position: inside;
            padding-left: 0.5rem;
        }
        .help-section li {
            margin-bottom: 0.75rem;
        }
        .help-section code {
            background: rgba(0, 255, 255, 0.1);
            padding: 3px 6px;
            border-radius: 4px;
            font-family: monospace;
            color: var(--cyan-glow);
        }


        /* --- Diseño Responsivo --- */
        @media (max-width: 768px) {
            #control-panel {
                width: calc(100% - 40px);
                max-height: calc(100% - 90px);
                overflow-y: auto;
            }
            .panel-title { font-size: 1.2rem; }
            #legend { 
                top: 20px;
                right: auto;
                left: 20px;
                bottom: auto;
                width: calc(100% - 40px);
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <canvas id="canvas"></canvas>

        <!-- Panel de Control Flotante -->
        <div id="control-panel" class="floating-panel">
            <header class="panel-header" id="panel-header">
                <h1 class="panel-title">CONTROLES</h1>
                <svg id="panel-toggle-icon" class="panel-toggle-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M18.75 19.5l-7.5-7.5 7.5-7.5m-6 15L5.25 12l7.5-7.5" /></svg>
            </header>
            <div class="panel-content">
                <div class="input-group">
                    <label class="input-label">Funciones Predefinidas</label>
                    <div class="preset-grid">
                        <button class="preset-btn active modern-btn" data-func="sin(x)">sin(x)</button>
                        <button class="preset-btn modern-btn" data-func="cos(x)">cos(x)</button>
                        <button class="preset-btn modern-btn" data-func="exp(x)">e^x</button>
                        <button class="preset-btn modern-btn" data-func="log(x+1)">ln(x+1)</button>
                        <button class="preset-btn modern-btn" data-func="1/(1-x)">1/(1-x)</button>
                        <button class="preset-btn modern-btn" data-func="atan(x)">atan(x)</button>
                    </div>
                </div>
                <div class="input-group">
                    <label for="function-input" class="input-label">Función f(x)</label>
                    <input type="text" id="function-input" class="futuristic-input" value="sin(x)">
                </div>
                <div class="input-group">
                    <label for="expansion-point" class="input-label">Punto de Expansión (a) = <span id="point-value">0.0</span></label>
                    <input type="range" id="expansion-point" class="w-full" min="-3" max="3" step="0.1" value="0">
                </div>
                <div class="input-group">
                    <label for="max-terms" class="input-label">Número de Términos</label>
                    <input type="number" id="max-terms" class="futuristic-input" value="7" min="1" max="20">
                </div>
                <div class="input-group">
                    <label class="input-label">Colores de Gráfica</label>
                    <div style="display: flex; justify-content: space-around;">
                        <div>
                            <label for="original-color-picker" class="input-label" style="font-size:0.8rem;">f(x)</label>
                            <input type="color" id="original-color-picker" value="#FFD60A">
                        </div>
                        <div>
                            <label for="taylor-color-picker" class="input-label" style="font-size:0.8rem;">Taylor</label>
                            <input type="color" id="taylor-color-picker" value="#00FFFF">
                        </div>
                    </div>
                </div>
                 <div class="input-group" style="display: flex; align-items: center; justify-content: space-between;">
                    <label for="show-error-toggle" class="input-label" style="margin-bottom: 0;">Mostrar Error</label>
                    <input type="checkbox" id="show-error-toggle" />
                </div>
                <div class="input-group" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                    <button id="show-formula-btn" class="modern-btn">📜 Fórmulas</button>
                    <button id="show-help-btn" class="modern-btn">❓ Ayuda</button>
                </div>
            </div>
        </div>

        <!-- Leyenda -->
        <div id="legend" class="floating-panel">
            <div class="legend-item"><div id="legend-color-original" class="legend-color"></div>Función Original</div>
            <div class="legend-item"><div id="legend-color-taylor" class="legend-color"></div>Serie de Taylor</div>
            <div class="legend-item" id="error-legend-item"><div class="legend-color" style="background: var(--error-color)"></div>Error Absoluto</div>
        </div>

        <!-- Modal de Fórmulas -->
        <div id="formula-modal" class="modal-backdrop">
            <div class="modal-content">
                <header class="modal-header">
                    <h2 class="modal-title">Desarrollo de la Serie</h2>
                    <button id="close-formula-btn" class="modern-btn" style="width: 40px; height: 40px; padding: 0;">X</button>
                </header>
                <div class="modal-body">
                    <div class="formula-section">
                        <h3 class="input-label">Fórmula General de Taylor</h3>
                        <div class="formula-content">$$ f(x) \approx \sum_{n=0}^{N} \frac{f^{(n)}(a)}{n!} (x-a)^n $$</div>
                    </div>
                    <div class="formula-section" id="textbook-formula-section" style="display: none;">
                        <h3 class="input-label">Expansión de Maclaurin Conocida</h3>
                        <div class="formula-content" id="textbook-formula-content"></div>
                    </div>
                     <div class="formula-section">
                        <h3 class="input-label">Serie Calculada para <span id="modal-function-name"></span></h3>
                        <div class="formula-content" id="expanded-terms"></div>
                    </div>
                    <div class="formula-section">
                        <h3 class="input-label">Término de Error (Residuo de Lagrange)</h3>
                        <div class="formula-content">$$ R_n(x) = \frac{f^{(n+1)}(c)}{(n+1)!} (x-a)^{n+1} $$</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Modal de Ayuda -->
        <div id="help-modal" class="modal-backdrop">
            <div class="modal-content">
                <header class="modal-header">
                    <h2 class="modal-title" style="color: var(--yellow-accent);">Guía de la Holocubierta</h2>
                    <button id="close-help-btn" class="modern-btn" style="width: 40px; height: 40px; padding: 0;">X</button>
                </header>
                <div class="modal-body">
                    <div class="help-section">
                        <h3 class="help-title">🚀 Misión: Series de Taylor</h3>
                        <p>¡Bienvenido, cadete! Tu misión es explorar cómo funciones complejas pueden ser aproximadas por polinomios más simples. Una Serie de Taylor es como un "plano de construcción" matemático que nos permite predecir el comportamiento de una función cerca de un punto específico.</p>
                    </div>
                    <div class="help-section">
                        <h3 class="help-title">✨ La Teoría Detrás de la Magia</h3>
                        <p>El objetivo es construir un polinomio que imite a la función original <code>f(x)</code> alrededor de un punto de expansión <code>a</code>. Para lograrlo, nos aseguramos de que el polinomio y la función original tengan el mismo valor y las mismas derivadas en ese punto.</p>
                        <ul>
                            <li><b>Término 0 (Posición):</b> El primer término, <code>f(a)</code>, asegura que ambas gráficas pasen por el mismo punto.</li>
                            <li><b>Término 1 (Velocidad):</b> El segundo término, con <code>f'(a)</code>, iguala las pendientes (la "velocidad" de cambio) de ambas gráficas.</li>
                            <li><b>Término 2 (Aceleración):</b> El tercer término, con <code>f''(a)</code>, iguala la concavidad (la "aceleración").</li>
                            <li><b>Y así sucesivamente...</b> Cada término adicional hace que la aproximación sea cada vez mejor en las cercanías del punto <code>a</code>.</li>
                            <li><b>Serie de Maclaurin:</b> Es simplemente un caso especial de la Serie de Taylor donde el punto de expansión es <code>a = 0</code>.</li>
                        </ul>
                    </div>
                    <div class="help-section">
                        <h3 class="help-title">🔭 El Lienzo Cósmico</h3>
                        <p>Esta es tu ventana al universo matemático. ¡Interactúa con él!</p>
                        <ul>
                            <li><b>Navegación 🖱️:</b> Haz clic y arrastra para moverte por el espacio-tiempo del gráfico.</li>
                            <li><b>Zoom de Curvatura 휠:</b> Usa la rueda del mouse para acercarte o alejarte.</li>
                            <li><b>Manipulación del Eje X ↔️:</b> Acerca el cursor al eje Y (vertical) y arrastra para estirar el universo horizontalmente.</li>
                            <li><b>Manipulación del Eje Y ↕️:</b> Acerca el cursor al eje X (horizontal) y arrastra para expandir la dimensión vertical.</li>
                            <li><b>Controles Táctiles 🖐️:</b> En tu PADD, usa un dedo para navegar y dos para hacer zoom.</li>
                        </ul>
                    </div>
                    <div class="help-section">
                        <h3 class="help-title">⚙️ Panel de Mando</h3>
                        <ul>
                            <li><b>Función <code>f(x)</code>:</b> Elige una función predefinida o introduce la tuya. ¡El motor de cálculo puede con casi todo!</li>
                            <li><b>Punto de Expansión <code>(a)</code>:</b> Este es el "punto de anclaje" de tu aproximación. La serie será más precisa cerca de este valor. ¡Desliza y observa cómo cambia la aproximación!</li>
                            <li><b>Número de Términos:</b> La cantidad de "piezas" que usas para construir tu polinomio. Más términos = más precisión, pero también más complejidad.</li>
                            <li><b>Mostrar Error:</b> Activa esta opción para visualizar la "zona de divergencia" (el área roja), que muestra la diferencia entre la función real y tu aproximación.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // --- Setup ---
        const dom = {
            canvas: document.getElementById('canvas'),
            functionInput: document.getElementById('function-input'),
            expansionPointSlider: document.getElementById('expansion-point'),
            pointValue: document.getElementById('point-value'),
            maxTermsInput: document.getElementById('max-terms'),
            controlPanel: document.getElementById('control-panel'),
            panelHeader: document.getElementById('panel-header'),
            showErrorToggle: document.getElementById('show-error-toggle'),
            errorLegendItem: document.getElementById('error-legend-item'),
            originalColorPicker: document.getElementById('original-color-picker'),
            taylorColorPicker: document.getElementById('taylor-color-picker'),
            legendColorOriginal: document.getElementById('legend-color-original'),
            legendColorTaylor: document.getElementById('legend-color-taylor'),
            formulaModal: document.getElementById('formula-modal'),
            modalFunctionName: document.getElementById('modal-function-name'),
            expandedTerms: document.getElementById('expanded-terms'),
            showFormulaBtn: document.getElementById('show-formula-btn'),
            closeFormulaBtn: document.getElementById('close-formula-btn'),
            textbookFormulaSection: document.getElementById('textbook-formula-section'),
            textbookFormulaContent: document.getElementById('textbook-formula-content'),
            helpModal: document.getElementById('help-modal'),
            showHelpBtn: document.getElementById('show-help-btn'),
            closeHelpBtn: document.getElementById('close-help-btn'),
        };
        const ctx = dom.canvas.getContext('2d');
        let currentFunction = 'sin(x)';
        let expansionPoint = 0;
        let maxTerms = 7;
        let taylorPolynomial;
        let taylorPolynomialLatex;
        let showError = false;

        const textbookFormulas = {
            'sin(x)': '$$ \\sin(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n}{(2n+1)!} x^{2n+1} = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\cdots $$',
            'cos(x)': '$$ \\cos(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n}{(2n)!} x^{2n} = 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\cdots $$',
            'exp(x)': '$$ e^x = \\sum_{n=0}^{\\infty} \\frac{x^n}{n!} = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots $$',
            'log(x+1)': '$$ \\ln(1+x) = \\sum_{n=1}^{\\infty} \\frac{(-1)^{n+1}}{n} x^n = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \\cdots $$',
            '1/(1-x)': '$$ \\frac{1}{1-x} = \\sum_{n=0}^{\\infty} x^n = 1 + x + x^2 + x^3 + \\cdots, \\quad |x|<1 $$',
            'atan(x)': '$$ \\arctan(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^n}{2n+1} x^{2n+1} = x - \\frac{x^3}{3} + \\frac{x^5}{5} - \\cdots $$'
        };

        let view = {
            centerX: 0,
            centerY: 0,
            zoomX: 50,
            zoomY: 50,
            isDragging: false,
            isScaling: false,
            scalingAxis: 'none',
            hoveringAxis: 'none',
            lastMouse: { x: 0, y: 0 },
            lastPinchDist: null,
        };
        let animationFrameId;

        let originalFuncColor = '#FFD60A';
        let taylorSeriesColor = '#00FFFF';
        const errorColor = getComputedStyle(document.documentElement).getPropertyValue('--error-color').trim();

        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            setupCanvas();
            calculateTaylor();
            if (window.innerWidth <= 768) {
                dom.controlPanel.classList.add('collapsed');
            }
        });
        
        function setupCanvas() {
            const container = document.getElementById('app-container');
            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            
            dom.canvas.width = rect.width * dpr;
            dom.canvas.height = rect.height * dpr;
            dom.canvas.style.width = `${rect.width}px`;
            dom.canvas.style.height = `${rect.height}px`;
            
            requestDraw();
        }

        function setupEventListeners() {
            window.addEventListener('resize', setupCanvas);

            // Controles del panel
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelector('.preset-btn.active').classList.remove('active');
                    btn.classList.add('active');
                    dom.functionInput.value = btn.dataset.func;
                    calculateTaylor();
                });
            });
            dom.functionInput.addEventListener('change', calculateTaylor);
            dom.expansionPointSlider.addEventListener('input', e => {
                expansionPoint = parseFloat(e.target.value);
                dom.pointValue.textContent = expansionPoint.toFixed(1);
                calculateTaylor();
            });
            dom.maxTermsInput.addEventListener('input', calculateTaylor);

            dom.panelHeader.addEventListener('click', () => {
                dom.controlPanel.classList.toggle('collapsed');
            });

            // Colores y Error
            dom.originalColorPicker.addEventListener('input', e => {
                originalFuncColor = e.target.value;
                updateLegendColors();
                requestDraw();
            });
            dom.taylorColorPicker.addEventListener('input', e => {
                taylorSeriesColor = e.target.value;
                updateLegendColors();
                requestDraw();
            });
            dom.showErrorToggle.addEventListener('change', e => {
                showError = e.target.checked;
                dom.errorLegendItem.style.display = showError ? 'flex' : 'none';
                requestDraw();
            });
            updateLegendColors();

            // Modals
            dom.showFormulaBtn.addEventListener('click', showFormulaModal);
            dom.closeFormulaBtn.addEventListener('click', hideFormulaModal);
            dom.formulaModal.addEventListener('click', (e) => {
                if (e.target === dom.formulaModal) hideFormulaModal();
            });
            
            dom.showHelpBtn.addEventListener('click', showHelpModal);
            dom.closeHelpBtn.addEventListener('click', hideHelpModal);
            dom.helpModal.addEventListener('click', (e) => {
                if (e.target === dom.helpModal) hideHelpModal();
            });


            // Eventos del Canvas (Mouse)
            dom.canvas.addEventListener('mousedown', e => {
                if (view.hoveringAxis !== 'none') {
                    view.isScaling = true;
                    view.scalingAxis = view.hoveringAxis;
                } else {
                    view.isDragging = true;
                }
                view.lastMouse = { x: e.offsetX, y: e.offsetY };
            });

            dom.canvas.addEventListener('mousemove', e => {
                const mousePos = { x: e.offsetX, y: e.offsetY };
                if (view.isScaling) {
                    const worldCoords = screenToWorld(mousePos.x, mousePos.y);
                    if (view.scalingAxis === 'x') {
                        const scaleFactor = 1 - (mousePos.x - view.lastMouse.x) * 0.01;
                        view.zoomX *= scaleFactor;
                        dom.canvas.style.cursor = 'ew-resize';
                    } else if (view.scalingAxis === 'y') {
                        const scaleFactor = 1 + (mousePos.y - view.lastMouse.y) * 0.01;
                        view.zoomY *= scaleFactor;
                        dom.canvas.style.cursor = 'ns-resize';
                    }
                    const newWorldCoords = screenToWorld(mousePos.x, mousePos.y);
                    view.centerX += worldCoords.x - newWorldCoords.x;
                    view.centerY += worldCoords.y - newWorldCoords.y;
                    requestDraw();
                } else if (view.isDragging) {
                    const dx = mousePos.x - view.lastMouse.x;
                    const dy = mousePos.y - view.lastMouse.y;
                    view.centerX -= dx / view.zoomX;
                    view.centerY += dy / view.zoomY;
                    dom.canvas.style.cursor = 'grabbing';
                    requestDraw();
                } else {
                    const origin = worldToScreen(0, 0);
                    const threshold = 10;
                    if (Math.abs(mousePos.y - origin.y) < threshold) {
                        view.hoveringAxis = 'x';
                        dom.canvas.style.cursor = 'ew-resize';
                    } else if (Math.abs(mousePos.x - origin.x) < threshold) {
                        view.hoveringAxis = 'y';
                        dom.canvas.style.cursor = 'ns-resize';
                    } else {
                        view.hoveringAxis = 'none';
                        dom.canvas.style.cursor = 'grab';
                    }
                }
                view.lastMouse = mousePos;
            });

            dom.canvas.addEventListener('mouseup', () => {
                view.isDragging = false;
                view.isScaling = false;
            });
            dom.canvas.addEventListener('mouseleave', () => {
                view.isDragging = false;
                view.isScaling = false;
                view.hoveringAxis = 'none';
                dom.canvas.style.cursor = 'grab';
            });
            
            dom.canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const worldCoords = screenToWorld(e.offsetX, e.offsetY);
                const zoomFactor = e.deltaY < 0 ? 1.15 : 0.85;
                view.zoomX *= zoomFactor;
                view.zoomY *= zoomFactor;
                const newWorldCoords = screenToWorld(e.offsetX, e.offsetY);
                view.centerX += worldCoords.x - newWorldCoords.x;
                view.centerY += worldCoords.y - newWorldCoords.y;
                requestDraw();
            });
            
            // Eventos del Canvas (Táctil)
            dom.canvas.addEventListener('touchstart', e => {
                if (e.touches.length === 1) {
                    view.isDragging = true;
                    view.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    view.isDragging = false;
                    view.lastPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                }
            }, { passive: false });

            dom.canvas.addEventListener('touchmove', e => {
                e.preventDefault();
                if (view.isDragging && e.touches.length === 1) {
                    const dx = e.touches[0].clientX - view.lastMouse.x;
                    const dy = e.touches[0].clientY - view.lastMouse.y;
                    view.lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    view.centerX -= dx / view.zoomX;
                    view.centerY += dy / view.zoomY;
                    requestDraw();
                } else if (e.touches.length === 2) {
                    const currentPinchDist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    const zoomFactor = currentPinchDist / view.lastPinchDist;
                    view.zoomX *= zoomFactor;
                    view.zoomY *= zoomFactor;
                    view.lastPinchDist = currentPinchDist;
                    requestDraw();
                }
            }, { passive: false });

            dom.canvas.addEventListener('touchend', () => {
                view.isDragging = false;
                view.lastPinchDist = null;
            });
        }
        
        function updateLegendColors() {
            dom.legendColorOriginal.style.background = originalFuncColor;
            dom.legendColorTaylor.style.background = taylorSeriesColor;
        }

        // --- Lógica de Cálculo ---
        function calculateTaylor() {
            currentFunction = dom.functionInput.value;
            expansionPoint = parseFloat(dom.expansionPointSlider.value);
            maxTerms = parseInt(dom.maxTermsInput.value);

            try {
                let node = math.parse(currentFunction);
                const terms = [];
                const latexTerms = [];
                for (let i = 0; i < maxTerms; i++) {
                    const derivativeValue = node.evaluate({ x: expansionPoint });
                    const termCoeff = derivativeValue / math.factorial(i);
                    if (Math.abs(termCoeff) > 1e-9) {
                        terms.push(`${termCoeff} * (x - ${expansionPoint})^${i}`);
                        
                        let sign = (termCoeff > 0) ? '+' : '-';
                        const absCoeff = Math.abs(termCoeff);
                        let coeffStr = absCoeff.toFixed(2).replace(/\.?0+$/, '');
                        if (Math.abs(absCoeff - 1) < 1e-9 && i > 0) coeffStr = '';
                        
                        let xPart = '';
                        if (i > 0) {
                            const powerStr = (i > 1) ? `^{${i}}` : '';
                            const aStr = Math.abs(expansionPoint);
                            if (expansionPoint === 0) {
                                xPart = `x${powerStr}`;
                            } else {
                                xPart = `(x ${expansionPoint > 0 ? '-' : '+'} ${aStr})${powerStr}`;
                            }
                        }
                        
                        if (latexTerms.length === 0 && sign === '+') sign = '';
                        
                        latexTerms.push(`${sign} ${coeffStr} ${xPart}`);
                    }
                    node = math.derivative(node, 'x');
                }
                taylorPolynomial = terms.join(' + ') || '0';
                taylorPolynomialLatex = latexTerms.join(' ').trim();
            } catch (e) {
                console.error("Error al calcular la serie de Taylor:", e);
                taylorPolynomial = "0";
                taylorPolynomialLatex = `\\text{Error: ${e.message}}`;
            }
            requestDraw();
        }

        // --- Lógica de Dibujo ---
        function requestDraw() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(drawScene);
        }

        function drawScene() {
            if (!ctx) return;
            const dpr = window.devicePixelRatio || 1;
            const rect = dom.canvas.getBoundingClientRect();

            ctx.save();
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, rect.width, rect.height);
            
            drawGridAndAxes();
            
            if (showError && taylorPolynomial) {
                drawErrorFunction();
            }
            if (taylorPolynomial) {
                drawFunction(taylorPolynomial, taylorSeriesColor, 2.5);
            }
            drawFunction(currentFunction, originalFuncColor, 3);

            ctx.restore();
        }

        function drawGridAndAxes() {
            ctx.save();
            const rect = dom.canvas.getBoundingClientRect();
            const viewExtents = {
                left: view.centerX - (rect.width / 2) / view.zoomX,
                right: view.centerX + (rect.width / 2) / view.zoomX,
                top: view.centerY + (rect.height / 2) / view.zoomY,
                bottom: view.centerY - (rect.height / 2) / view.zoomY,
            };

            const minPixelSpacing = 70;
            let xStep = Math.pow(10, Math.floor(Math.log10(viewExtents.right - viewExtents.left)) - 1);
            while(xStep * view.zoomX < minPixelSpacing) {
                xStep *= 2;
                if(xStep * view.zoomX > minPixelSpacing * 2.5) { xStep /= 2.5; break; }
            }

            let yStep = Math.pow(10, Math.floor(Math.log10(viewExtents.top - viewExtents.bottom)) - 1);
             while(yStep * view.zoomY < minPixelSpacing) {
                yStep *= 2;
                 if(yStep * view.zoomY > minPixelSpacing * 2.5) { yStep /= 2.5; break; }
            }
            
            ctx.strokeStyle = 'rgba(0, 191, 255, 0.2)';
            ctx.lineWidth = 1;
            
            for (let x = Math.floor(viewExtents.left / xStep) * xStep; x < viewExtents.right; x += xStep) {
                const screenX = worldToScreen(x, 0).x;
                ctx.beginPath(); ctx.moveTo(screenX, 0); ctx.lineTo(screenX, rect.height); ctx.stroke();
            }
            for (let y = Math.floor(viewExtents.bottom / yStep) * yStep; y < viewExtents.top; y += yStep) {
                const screenY = worldToScreen(0, y).y;
                ctx.beginPath(); ctx.moveTo(0, screenY); ctx.lineTo(rect.width, screenY); ctx.stroke();
            }

            const origin = worldToScreen(0, 0);
            ctx.strokeStyle = '#FFFFFF';
            ctx.fillStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.font = "bold 14px Orbitron";

            ctx.beginPath();
            ctx.moveTo(0, origin.y); ctx.lineTo(rect.width, origin.y);
            ctx.moveTo(origin.x, 0); ctx.lineTo(origin.x, rect.height);
            ctx.stroke();
            
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            for (let x = Math.floor(viewExtents.left / xStep) * xStep; x < viewExtents.right; x += xStep) {
                if (Math.abs(x) > 1e-9) {
                    ctx.fillText(x.toPrecision(2).replace(/\.0+$/, ''), worldToScreen(x, 0).x, origin.y + 8);
                }
            }

            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            for (let y = Math.floor(viewExtents.bottom / yStep) * yStep; y < viewExtents.top; y += yStep) {
                 if (Math.abs(y) > 1e-9) {
                    ctx.fillText(y.toPrecision(2).replace(/\.0+$/, ''), origin.x - 8, worldToScreen(0, y).y);
                }
            }
            
            ctx.textAlign = "right";
            ctx.textBaseline = "top";
            ctx.fillText("0", origin.x - 8, origin.y + 8);

            ctx.restore();
        }

        function drawFunction(funcStr, color, lineWidth) {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.shadowColor = color;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            
            const rect = dom.canvas.getBoundingClientRect();
            const step = 1; // 1 pixel en pantalla
            
            let firstPoint = true;
            try {
                const node = math.parse(funcStr);
                for (let sx = 0; sx < rect.width; sx += step) {
                    const x = screenToWorld(sx, 0).x;
                    const y = node.evaluate({x: x});
                    if (isNaN(y) || !isFinite(y)) {
                        firstPoint = true; continue;
                    }
                    const screenPos = worldToScreen(x, y);
                    if (firstPoint) {
                        ctx.moveTo(screenPos.x, screenPos.y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(screenPos.x, screenPos.y);
                    }
                }
            } catch (e) { /* No dibujar si la función es inválida */ }
            ctx.stroke();
            ctx.restore();
        }
        
        function drawErrorFunction() {
            ctx.save();
            ctx.fillStyle = errorColor.replace(')', ', 0.2)');
            ctx.strokeStyle = errorColor;
            ctx.lineWidth = 2;
            
            const rect = dom.canvas.getBoundingClientRect();
            const step = 2; // 2 pixeles
            
            const originalNode = math.parse(currentFunction);
            const taylorNode = math.parse(taylorPolynomial);
            
            const errorPoints = [];

            for (let sx = 0; sx < rect.width; sx += step) {
                 const x = screenToWorld(sx, 0).x;
                try {
                    const originalY = originalNode.evaluate({x: x});
                    const taylorY = taylorNode.evaluate({x: x});
                    const error = Math.abs(originalY - taylorY);
                    if (!isNaN(error) && isFinite(error)) {
                        errorPoints.push({x, y: error});
                    }
                } catch(e) {}
            }
            
            ctx.beginPath();
            const startPoint = worldToScreen(errorPoints[0]?.x || 0, 0);
            ctx.moveTo(startPoint.x, startPoint.y);

            for(const point of errorPoints) {
                const screenPos = worldToScreen(point.x, point.y);
                ctx.lineTo(screenPos.x, screenPos.y);
            }
            ctx.stroke();
            
            if(errorPoints.length > 1) {
                const endPoint = worldToScreen(errorPoints[errorPoints.length - 1].x, 0);
                ctx.lineTo(endPoint.x, endPoint.y);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        // --- Utilidades ---
        function worldToScreen(wx, wy) {
            const rect = dom.canvas.getBoundingClientRect();
            const sx = (wx - view.centerX) * view.zoomX + rect.width / 2;
            const sy = -(wy - view.centerY) * view.zoomY + rect.height / 2;
            return { x: sx, y: sy };
        }

        function screenToWorld(sx, sy) {
            const rect = dom.canvas.getBoundingClientRect();
            const wx = (sx - rect.width / 2) / view.zoomX + view.centerX;
            const wy = -(sy - rect.height / 2) / view.zoomY + view.centerY;
            return { x: wx, y: wy };
        }

        function showFormulaModal() {
            dom.modalFunctionName.textContent = currentFunction;
            dom.expandedTerms.textContent = `$$ f(x) \\approx ${taylorPolynomialLatex || ''} $$`;

            const textbookFormula = textbookFormulas[currentFunction];
            if (textbookFormula && expansionPoint === 0) {
                dom.textbookFormulaContent.innerHTML = textbookFormula;
                dom.textbookFormulaSection.style.display = 'block';
            } else {
                dom.textbookFormulaSection.style.display = 'none';
            }

            dom.formulaModal.classList.add('active');
            if (window.MathJax) {
                MathJax.typesetPromise([dom.formulaModal])
                .catch((err) => console.error('MathJax error:', err));
            }
        }

        function hideFormulaModal() {
            dom.formulaModal.classList.remove('active');
        }

        // NUEVO: Funciones para el modal de ayuda
        function showHelpModal() {
            dom.helpModal.classList.add('active');
        }
        function hideHelpModal() {
            dom.helpModal.classList.remove('active');
        }
        
    </script>
</body>
</ht