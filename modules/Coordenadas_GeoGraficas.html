<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üåç Simulador Geoespacial 3D Avanzado</title>
    <style>
        :root {
            --primary-color: #5b9dff;
            --panel-bg: rgba(20, 25, 40, 0.8);
            --text-color: #f0f0f0;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --input-bg: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: var(--text-color);
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #bg-canvas, #scene-container, #labels-container {
            position: fixed;
            inset: 0;
            z-index: 1;
        }
        #bg-canvas { z-index: 0; }
        #labels-container { 
            z-index: 2; 
            pointer-events: none;
        }
        .label {
            color: #fff;
            font-size: 14px;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
            background: rgba(0,0,0,0.3);
            padding: 2px 5px;
            border-radius: 4px;
        }
        .marker-label {
            font-size: 12px;
            color: #ffc;
            transform: translate(15px, -15px);
        }

        .loader {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #05080a;
            z-index: 1000;
            transition: opacity 0.8s ease;
        }

        .loader .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.15);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1.2s linear infinite;
            margin-bottom: 20px;
        }
        
        .loader .progress-text {
            font-size: 1em;
            color: #aaa;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 340px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            padding: 20px;
            border-radius: 16px;
            z-index: 10;
            background: var(--panel-bg);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px var(--shadow-color);
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            transform-origin: top left;
        }

        #panel.hidden {
            transform: translateX(-120%);
        }

        .section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .section:last-child { border-bottom: none; }

        .section h3 {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .input-group {
            margin-bottom: 12px;
        }
        .input-group label {
            display: block;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #ccc;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        input[type=range] {
            flex: 1;
            -webkit-appearance: none;
            height: 5px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.15);
            cursor: pointer;
            transition: background 0.2s;
        }
        input[type=range]:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(91, 157, 255, 0.7);
        }
        .value-display {
            width: 75px;
            text-align: center;
            background: var(--input-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 5px 8px;
            font-size: 0.9em;
            color: #fff;
        }
        
        #search-input, #city-selector, #date-input {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: var(--input-bg);
            color: #fff;
            font-size: 1em;
            margin-top: 10px;
        }
        #search-input::placeholder { color: #888; }
        
        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            cursor: pointer;
            padding: 8px 5px;
            border-radius: 8px;
            transition: background-color 0.2s;
        }
        .toggle-switch:hover {
            background-color: rgba(255,255,255,0.05);
        }
        .switch {
            width: 50px;
            height: 28px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 14px;
            position: relative;
            transition: background-color 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #fff;
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .switch.on { background: var(--primary-color); }
        .switch.on::after { transform: translateX(22px); }

        .button-row { display: flex; gap: 10px; margin-top: 15px; }
        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn.primary { background: var(--primary-color); color: #fff; }
        .btn.primary:hover { background: #7aaeff; }
        .btn.secondary { background: rgba(255, 255, 255, 0.15); color: #fff; }
        .btn.secondary:hover { background: rgba(255, 255, 255, 0.25); }

        #info-box {
            position: absolute;
            bottom: 20px;
            right: 20px;
            max-width: 300px;
            padding: 15px;
            border-radius: 12px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9em;
            z-index: 5;
        }
        #info-box p { margin-bottom: 5px; }
        #info-box p:last-child { margin-bottom: 0; }
        #info-box span { font-weight: bold; color: var(--primary-color); }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 5;
        }
        .zoom-controls button {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: var(--panel-bg);
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .zoom-controls button:hover { background: rgba(255, 255, 255, 0.2); }

        #panel-toggle {
            display: flex;
            position: fixed;
            top: 20px;
            left: 20px;
            width: 48px;
            height: 48px;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: var(--panel-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 11;
            cursor: pointer;
        }
        #panel-toggle svg {
            width: 28px;
            height: 28px;
            color: #fff;
            transition: transform 0.3s;
        }

        @media (max-width: 768px) {
            #panel {
                width: calc(100% - 40px);
                transform: translateX(-50%);
                left: 50%;
            }
            #panel.hidden { transform: translate(-50%, -120%); }
            .zoom-controls { left: auto; right: 20px; }
            #info-box {
                bottom: 80px;
                right: 50%;
                transform: translateX(50%);
                width: calc(100% - 40px);
                max-width: none;
            }
        }
    </style>
</head>
<body>

    <div class="loader" id="loader">
        <div class="spinner"></div>
        <div class="progress-text" id="progress-text">Inicializando...</div>
    </div>

    <canvas id="bg-canvas"></canvas>
    <div id="scene-container"></div>
    <div id="labels-container"></div>

    <button id="panel-toggle">
        <svg id="menu-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
        <svg id="close-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
    </button>

    <div id="panel" class="hidden">
        <div class="section">
            <h3>‚òÄÔ∏è Control del Tiempo</h3>
             <div class="input-group">
                <label for="date-input">Fecha</label>
                <input type="date" id="date-input">
            </div>
        </div>

        <div class="section">
            <h3>üìç Ubicaci√≥n Geogr√°fica</h3>
            <div class="input-group">
                <input type="text" id="search-input" placeholder="Buscar ciudad, pa√≠s...">
                 <select id="city-selector">
                    <option value="">O selecciona una ciudad</option>
                    <option value="4.71,-74.07">Bogot√°</option>
                    <option value="34.05,-118.24">Los Angeles</option>
                    <option value="40.71,-74.00">Nueva York</option>
                    <option value="48.85,2.35">Par√≠s</option>
                    <option value="51.50,-0.12">Londres</option>
                    <option value="35.68,139.69">Tokio</option>
                    <option value="-33.86,151.20">S√≠dney</option>
                </select>
            </div>
            <div class="input-group">
                <label for="lat-slider">Latitud</label>
                <div class="slider-row">
                    <input type="range" id="lat-slider" min="-90" max="90" step="0.1" value="0">
                    <div class="value-display" id="lat-value">0.0¬∞</div>
                </div>
            </div>
            <div class="input-group">
                <label for="lon-slider">Longitud</label>
                <div class="slider-row">
                    <input type="range" id="lon-slider" min="-180" max="180" step="0.1" value="0">
                    <div class="value-display" id="lon-value">0.0¬∞</div>
                </div>
            </div>
             <div class="button-row">
                <button class="btn secondary" id="reset-view-btn">Restablecer Vista</button>
                <button class="btn primary" id="goto-btn">Ir a Ubicaci√≥n</button>
            </div>
        </div>

        <div class="section">
            <h3>üé® Visualizaci√≥n del Planeta</h3>
            <div class="toggle-switch" data-prop="showAtmosphere"><span>Atm√≥sfera</span><div class="switch on"></div></div>
            <div class="toggle-switch" data-prop="showClouds"><span>Nubes</span><div class="switch on"></div></div>
            <div class="toggle-switch" data-prop="showNight"><span>Luces Nocturnas</span><div class="switch on"></div></div>
            <div class="toggle-switch" data-prop="autoRotate"><span>Rotaci√≥n Autom√°tica</span><div class="switch"></div></div>
        </div>

        <div class="section">
            <h3>üìè L√≠neas Geogr√°ficas</h3>
            <div class="toggle-switch" data-prop="showEquator"><span>Ecuador</span><div class="switch on"></div></div>
            <div class="toggle-switch" data-prop="showTropics"><span>Tr√≥picos</span><div class="switch on"></div></div>
            <div class="toggle-switch" data-prop="showGreenwich"><span>Meridiano 0¬∞</span><div class="switch on"></div></div>
            <div class="toggle-switch" data-prop="showGrid"><span>Cuadr√≠cula</span><div class="switch"></div></div>
            <div class="toggle-switch" data-prop="showMarkerLines"><span>L√≠neas del Punto</span><div class="switch on"></div></div>
        </div>
    </div>

    <div id="info-box">
        <p><strong>Hemisferio:</strong> <span id="info-hemisphere">--</span></p>
        <p><strong>Zona Clim√°tica:</strong> <span id="info-zone">--</span></p>
    </div>

    <div class="zoom-controls">
        <button id="zoom-in-btn">Ôºã</button>
        <button id="zoom-out-btn">Ôºç</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        
        const config = {
            earthRadius: 1,
            axialTilt: 23.5 // Grados
        };

        const state = {
            lat: 4.60971,
            lon: -74.08175,
            showAtmosphere: true,
            showClouds: true,
            showNight: true,
            showEquator: true,
            showTropics: true,
            showGreenwich: true,
            showGrid: false,
            showMarkerLines: true,
            autoRotate: false,
            currentDate: new Date()
        };

        let three, ui, assets;

        class ThreeApp {
            constructor(container, labelContainer, assets) {
                this.container = container;
                this.assets = assets;

                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 3.5);
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(this.renderer.domElement);

                this.labelRenderer = new CSS2DRenderer();
                this.labelRenderer.setSize(container.clientWidth, container.clientHeight);
                this.labelRenderer.domElement.style.position = 'absolute';
                this.labelRenderer.domElement.style.top = '0px';
                labelContainer.appendChild(this.labelRenderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.enableZoom = true;
                this.controls.enablePan = true;
                this.controls.minDistance = 1.2;
                this.controls.maxDistance = 10;
                this.controls.autoRotateSpeed = 0.3;

                this.world = new THREE.Group();
                this.world.rotation.z = THREE.MathUtils.degToRad(config.axialTilt); // Apply axial tilt
                this.scene.add(this.world);
                
                this.createLights();
                this.createEarth();
                this.createAtmosphere();
                this.createClouds();
                this.createMarker();
                this.createGeoLines();
                this.createGrid();
                this.createLabels();
                this.createStarfield();
            }

            createLights() {
                this.scene.add(new THREE.AmbientLight(0x222222)); // Reduced ambient light
                this.sunLight = new THREE.DirectionalLight(0xffffff, 4.0);
                this.scene.add(this.sunLight);
            }

            createEarth() {
                const material = new THREE.MeshPhongMaterial({
                    map: this.assets.day,
                    bumpMap: this.assets.bump,
                    bumpScale: 0.02,
                    specularMap: this.assets.specular,
                    specular: new THREE.Color(0xcccccc),
                    shininess: 15,
                });

                material.onBeforeCompile = (shader) => {
                    shader.uniforms.nightTexture = { value: this.assets.night };
                    shader.uniforms.showNight = { value: 1.0 };
                    shader.fragmentShader = 'uniform sampler2D nightTexture;\n' + 'uniform float showNight;\n' + shader.fragmentShader;
                    shader.fragmentShader = shader.fragmentShader.replace(
                        'gl_FragColor = vec4( outgoingLight, diffuseColor.a );',
                        `vec3 nightColor = texture2D(nightTexture, vUv).rgb;
                         float darkness = 1.0 - max(0.0, dot(vNormal, directionalLights[0].direction));
                         darkness = smoothstep(0.3, 0.7, darkness);
                         vec3 finalColor = mix(outgoingLight, outgoingLight * nightColor, darkness * showNight);
                         gl_FragColor = vec4( finalColor, diffuseColor.a );`
                    );
                    this.earth.material.uniforms = shader.uniforms;
                };
                // Use higher resolution geometry for a smoother sphere
                this.earth = new THREE.Mesh(new THREE.SphereGeometry(config.earthRadius, 128, 128), material);
                this.world.add(this.earth);
            }

            createAtmosphere() {
                // Advanced atmosphere shader for Rayleigh scattering
                const vertexShader = `
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    void main() {
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vViewPosition = -mvPosition.xyz;
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `;
                const fragmentShader = `
                    uniform vec3 sunDirection;
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    
                    const vec3 C_PRIMARY = vec3(0.3, 0.5, 0.9); // Atmosphere color

                    void main() {
                        vec3 viewDir = normalize(vViewPosition);
                        float sunDot = dot(sunDirection, vNormal);
                        
                        // Rim light
                        float rim = smoothstep(0.0, 1.0, 1.0 - dot(vNormal, viewDir));
                        rim = pow(rim, 3.0);

                        // Scattering
                        float scatter = smoothstep(0.0, 0.5, sunDot);
                        
                        vec3 color = C_PRIMARY * (rim + scatter * 0.4);
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `;
                this.atmosphere = new THREE.Mesh(
                    new THREE.SphereGeometry(config.earthRadius * 1.04, 128, 128),
                    new THREE.ShaderMaterial({
                        vertexShader,
                        fragmentShader,
                        uniforms: {
                           sunDirection: { value: new THREE.Vector3() }
                        },
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide,
                        transparent: true
                    })
                );
                this.world.add(this.atmosphere);
            }

            createClouds() {
                this.clouds = new THREE.Mesh(
                    new THREE.SphereGeometry(config.earthRadius * 1.015, 128, 128),
                    new THREE.MeshPhongMaterial({ 
                        map: this.assets.clouds, 
                        transparent: true, 
                        opacity: 0.4, 
                        depthWrite: false, 
                        blending: THREE.AdditiveBlending 
                    })
                );
                this.world.add(this.clouds);
            }

            createMarker() {
                this.marker = new THREE.Mesh(new THREE.SphereGeometry(0.02, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                const div = document.createElement('div');
                div.className = 'label marker-label';
                this.markerLabel = new CSS2DObject(div);
                this.marker.add(this.markerLabel);
                this.earth.add(this.marker);
            }
            
            createGeoLines() {
                this.geoLines = new THREE.Group();
                const createLine = (points, color) => new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.7 }));
                const createLatLine = (lat) => {
                    const points = [];
                    for (let i = 0; i <= 128; i++) points.push(latLonTo3D(lat, (i / 128) * 360 - 180, config.earthRadius * 1.001));
                    return points;
                };
                const createLonLine = (lon) => {
                    const points = [];
                    for (let i = -90; i <= 90; i++) points.push(latLonTo3D(i, lon, config.earthRadius * 1.001));
                    return points;
                };
                this.equatorLine = createLine(createLatLine(0), 0xffff00);
                this.tropicCancerLine = createLine(createLatLine(23.436), 0xffaa00);
                this.tropicCapricornLine = createLine(createLatLine(-23.436), 0xffaa00);
                this.greenwichLine = createLine(createLonLine(0), 0x00ddff);

                const dashedMaterial = new THREE.LineDashedMaterial({ color: 0xffffff, dashSize: 0.05, gapSize: 0.03, transparent: true, opacity: 0.8 });
                this.markerLatLine = new THREE.Line(new THREE.BufferGeometry(), dashedMaterial);
                this.markerLonLine = new THREE.Line(new THREE.BufferGeometry(), dashedMaterial);

                this.geoLines.add(this.equatorLine, this.tropicCancerLine, this.tropicCapricornLine, this.greenwichLine, this.markerLatLine, this.markerLonLine);
                this.earth.add(this.geoLines);
            }

            createGrid() {
                this.grid = new THREE.Group();
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
                const createLine = (points) => new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), lineMaterial);
                for (let lat = -60; lat <= 60; lat += 30) {
                    if (lat === 0) continue;
                    const points = [];
                    for (let i = 0; i <= 128; i++) points.push(latLonTo3D(lat, (i/128) * 360 - 180, config.earthRadius * 1.001));
                    this.grid.add(createLine(points));
                }
                for (let lon = -150; lon <= 180; lon += 30) {
                    if (lon === 0) continue;
                    const points = [];
                    for (let i = -90; i <= 90; i++) points.push(latLonTo3D(i, lon, config.earthRadius * 1.001));
                    this.grid.add(createLine(points));
                }
                this.earth.add(this.grid);
            }
            
            createLabels() {
                this.labels = new THREE.Group();
                const createLabel = (text, lat, lon, radiusOffset = 1.1) => {
                    const div = document.createElement('div');
                    div.className = 'label';
                    div.textContent = text;
                    const label = new CSS2DObject(div);
                    label.position.copy(latLonTo3D(lat, lon, config.earthRadius * radiusOffset));
                    return label;
                };
                this.equatorLabel = createLabel('Ecuador', 0, -90);
                this.tropicCancerLabel = createLabel('Tr√≥pico de C√°ncer', 23.436, -90);
                this.tropicCapricornLabel = createLabel('Tr√≥pico de Capricornio', -23.436, -90);
                this.labels.add(this.equatorLabel, this.tropicCancerLabel, this.tropicCapricornLabel);
                this.earth.add(this.labels);
            }

            createStarfield() {
                const canvas = document.getElementById('bg-canvas');
                const ctx = canvas.getContext('2d');
                const resize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
                resize();
                window.addEventListener('resize', resize);
                const stars = Array.from({ length: 500 }, () => ({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 1.2, alpha: Math.random() }));
                const drawStars = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    stars.forEach(star => {
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                        ctx.fill();
                        star.alpha += (Math.random() - 0.5) * 0.05;
                        if (star.alpha < 0) star.alpha = 0;
                        if (star.alpha > 1) star.alpha = 1;
                    });
                    requestAnimationFrame(drawStars);
                };
                drawStars();
            }

            update(lat, lon, date) {
                this.marker.position.copy(latLonTo3D(lat, lon, config.earthRadius * 1.005));
                this.markerLabel.element.textContent = `Lat: ${lat.toFixed(2)}¬∞, Lon: ${lon.toFixed(2)}¬∞`;
                this.updateMarkerLines(lat, lon);
                
                this.earth.rotation.y += 0.0005; // Simulate Earth's rotation
                this.clouds.rotation.y += 0.0006;

                const sunPos = getSunPosition(date);
                this.sunLight.position.copy(sunPos);

                // Update atmosphere shader uniform
                if(this.atmosphere && this.atmosphere.material.uniforms.sunDirection) {
                    const localSunDir = this.world.worldToLocal(this.sunLight.position.clone()).normalize();
                    this.atmosphere.material.uniforms.sunDirection.value.copy(localSunDir);
                }
            }

            updateMarkerLines(lat, lon) {
                const latPoints = [];
                for (let i = 0; i <= 128; i++) latPoints.push(latLonTo3D(lat, (i / 128) * 360 - 180, config.earthRadius * 1.001));
                this.markerLatLine.geometry.setFromPoints(latPoints);
                this.markerLatLine.computeLineDistances();

                const lonPoints = [];
                for (let i = -90; i <= 90; i++) lonPoints.push(latLonTo3D(i, lon, config.earthRadius * 1.001));
                this.markerLonLine.geometry.setFromPoints(lonPoints);
                this.markerLonLine.computeLineDistances();
            }

            applySettings(newState) {
                this.atmosphere.visible = newState.showAtmosphere;
                this.clouds.visible = newState.showClouds;
                this.equatorLine.visible = this.equatorLabel.visible = newState.showEquator;
                this.tropicCancerLine.visible = this.tropicCapricornLine.visible = this.tropicCancerLabel.visible = this.tropicCapricornLabel.visible = newState.showTropics;
                this.greenwichLine.visible = newState.showGreenwich;
                this.grid.visible = newState.showGrid;
                this.markerLatLine.visible = this.markerLonLine.visible = this.markerLabel.visible = newState.showMarkerLines;
                this.controls.autoRotate = newState.autoRotate;
                if (this.earth && this.earth.material.uniforms) {
                    this.earth.material.uniforms.showNight.value = newState.showNight ? 1.0 : 0.0;
                }
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.controls.update();
                this.update(state.lat, state.lon, state.currentDate);
                this.renderer.render(this.scene, this.camera);
                this.labelRenderer.render(this.scene, this.camera);
            }

            start() { this.animate(); }

            onResize() {
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.labelRenderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }
        }

        function setupUI() {
            const dom = {
                loader: document.getElementById('loader'),
                progressText: document.getElementById('progress-text'),
                panel: document.getElementById('panel'),
                panelToggle: document.getElementById('panel-toggle'),
                menuIcon: document.getElementById('menu-icon'),
                closeIcon: document.getElementById('close-icon'),
                dateInput: document.getElementById('date-input'),
                latSlider: document.getElementById('lat-slider'),
                lonSlider: document.getElementById('lon-slider'),
                latValue: document.getElementById('lat-value'),
                lonValue: document.getElementById('lon-value'),
                searchInput: document.getElementById('search-input'),
                citySelector: document.getElementById('city-selector'),
                gotoBtn: document.getElementById('goto-btn'),
                resetViewBtn: document.getElementById('reset-view-btn'),
                zoomInBtn: document.getElementById('zoom-in-btn'),
                zoomOutBtn: document.getElementById('zoom-out-btn'),
                infoHemisphere: document.getElementById('info-hemisphere'),
                infoZone: document.getElementById('info-zone'),
                toggleSwitches: document.querySelectorAll('.toggle-switch')
            };
            const today = new Date();
            dom.dateInput.value = today.toISOString().substring(0, 10);
            return {
                dom,
                updateLoader: (text) => { dom.progressText.textContent = text; },
                hideLoader: () => {
                    dom.loader.style.opacity = '0';
                    setTimeout(() => dom.loader.style.display = 'none', 800);
                },
                updateCoordinates: (lat, lon) => {
                    dom.latSlider.value = lat;
                    dom.lonSlider.value = lon;
                    dom.latValue.textContent = `${lat.toFixed(1)}¬∞`;
                    dom.lonValue.textContent = `${lon.toFixed(1)}¬∞`;
                },
                updateInfoPanel: (lat, lon) => {
                    const hemisphere = `${lat >= 0 ? 'Norte' : 'Sur'}, ${lon >= 0 ? 'Este' : 'Oeste'}`;
                    const absLat = Math.abs(lat);
                    const zone = absLat <= 23.436 ? 'Tropical' : absLat <= 66.564 ? 'Templada' : 'Polar';
                    dom.infoHemisphere.textContent = hemisphere;
                    dom.infoZone.textContent = zone;
                },
                syncSwitches: (currentState) => {
                     dom.toggleSwitches.forEach(sw => {
                        const prop = sw.dataset.prop;
                        const visualSwitch = sw.querySelector('.switch');
                        if (currentState[prop]) visualSwitch.classList.add('on');
                        else visualSwitch.classList.remove('on');
                    });
                }
            };
        }

        function setupEventListeners() {
            window.addEventListener('resize', () => three.onResize());
            ui.dom.latSlider.addEventListener('input', (e) => { state.lat = parseFloat(e.target.value); updateState(true, false); });
            ui.dom.lonSlider.addEventListener('input', (e) => { state.lon = parseFloat(e.target.value); updateState(true, false); });
            ui.dom.dateInput.addEventListener('change', (e) => { state.currentDate = new Date(e.target.value); });
            ui.dom.gotoBtn.addEventListener('click', () => goToLocation(true));
            ui.dom.resetViewBtn.addEventListener('click', () => { three.controls.reset(); tween(three.world.rotation, { x: 0, y: 0, z: THREE.MathUtils.degToRad(config.axialTilt) }, 1000); });
            ui.dom.zoomInBtn.addEventListener('click', () => { three.camera.position.multiplyScalar(1 / 1.2); });
            ui.dom.zoomOutBtn.addEventListener('click', () => { three.camera.position.multiplyScalar(1.2); });
            
            ui.dom.panelToggle.addEventListener('click', () => {
                const isHidden = ui.dom.panel.classList.toggle('hidden');
                ui.dom.menuIcon.style.display = isHidden ? 'block' : 'none';
                ui.dom.closeIcon.style.display = isHidden ? 'none' : 'block';
            });
            if (window.innerWidth <= 768) {
                ui.dom.panel.classList.add('hidden');
                ui.dom.menuIcon.style.display = 'block';
                ui.dom.closeIcon.style.display = 'none';
            } else {
                 ui.dom.panel.classList.remove('hidden');
                 ui.dom.menuIcon.style.display = 'none';
                 ui.dom.closeIcon.style.display = 'block';
            }
            
            ui.dom.citySelector.addEventListener('change', (e) => {
                if (!e.target.value) return;
                const [lat, lon] = e.target.value.split(',').map(parseFloat);
                state.lat = lat;
                state.lon = lon;
                updateState(true, true);
                goToLocation(true);
            });

            ui.dom.searchInput.addEventListener('keypress', async (e) => {
                if (e.key === 'Enter' && e.target.value.trim()) {
                    try {
                        const query = e.target.value.trim();
                        ui.updateLoader(`Buscando "${query}"...`);
                        const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(query)}`, { headers: { 'Accept-Language': 'es,en' } });
                        const data = await response.json();
                        if (data && data[0]) {
                            state.lat = parseFloat(data[0].lat);
                            state.lon = parseFloat(data[0].lon);
                            updateState(true, true);
                            goToLocation(true);
                        } else { alert('Ubicaci√≥n no encontrada.'); }
                    } catch (error) { console.error("Error en la b√∫squeda:", error); alert('Error de red al buscar la ubicaci√≥n.'); } 
                    finally { ui.hideLoader(); }
                }
            });

            ui.dom.toggleSwitches.forEach(sw => {
                sw.addEventListener('click', () => {
                    const prop = sw.dataset.prop;
                    state[prop] = !state[prop];
                    sw.querySelector('.switch').classList.toggle('on');
                    three.applySettings(state);
                    if (prop === 'autoRotate') three.controls.autoRotate = state.autoRotate;
                });
            });
        }
        
        function updateState(updateUI, update3D) {
            if (updateUI) {
                ui.updateCoordinates(state.lat, state.lon);
                ui.updateInfoPanel(state.lat, state.lon);
            }
            if (update3D) three.applySettings(state);
        }

        function goToLocation(animated = true) {
            if (state.autoRotate) {
                state.autoRotate = false;
                ui.syncSwitches(state);
                three.applySettings(state);
            }
            const targetRotation = { y: THREE.MathUtils.degToRad(-state.lon), x: THREE.MathUtils.degToRad(state.lat) };
            if (animated) tween(three.world.rotation, targetRotation, 1500);
            else { three.world.rotation.x = targetRotation.x; three.world.rotation.y = targetRotation.y; }
        }

        function latLonTo3D(lat, lon, radius) {
            const phi = THREE.MathUtils.degToRad(90 - lat);
            const theta = THREE.MathUtils.degToRad(lon + 180); 
            const x = -radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = -radius * Math.sin(phi) * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }

        function loadAssets(onLoad) {
            const manager = new THREE.LoadingManager();
            const loader = new THREE.TextureLoader(manager);
            const loadedAssets = {};

            // URLs from unpkg CDN and a reliable source for the clouds texture.
            const textureUrls = {
                day: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-day.jpg',
                bump: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-topology.png',
                specular: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-water.png',
                night: 'https://unpkg.com/three-globe@2.31.0/example/img/earth-night.jpg',
                clouds: 'https://cdn.jsdelivr.net/gh/jeromeetienne/threex.planets/images/earthcloudmap.jpg'
            };
            
            const onError = (key) => (err) => {
                console.error(`Failed to load texture: ${key} from ${textureUrls[key]}`, err);
            };

            loader.load(textureUrls.day, (texture) => loadedAssets.day = texture, undefined, onError('day'));
            loader.load(textureUrls.bump, (texture) => loadedAssets.bump = texture, undefined, onError('bump'));
            loader.load(textureUrls.specular, (texture) => loadedAssets.specular = texture, undefined, onError('specular'));
            loader.load(textureUrls.night, (texture) => loadedAssets.night = texture, undefined, onError('night'));
            loader.load(textureUrls.clouds, (texture) => loadedAssets.clouds = texture, undefined, onError('clouds'));

            manager.onProgress = (url, itemsLoaded, itemsTotal) => {
                ui.updateLoader(`Cargando texturas: ${itemsLoaded} / ${itemsTotal}`);
            };
            
            manager.onError = (url) => {
                ui.updateLoader(`Error al cargar: ${url.split('/').pop()}`);
                console.error('There was an error loading ' + url);
            };

            manager.onLoad = () => {
                if (Object.keys(loadedAssets).length < Object.keys(textureUrls).length) {
                     ui.updateLoader('Error: Fallaron algunas texturas.');
                     console.error('Some textures failed to load.', loadedAssets);
                }
                onLoad(loadedAssets);
            };
        }

        function getSunPosition(date) {
            const dayOfYear = (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - Date.UTC(date.getFullYear(), 0, 0)) / 86400000;
            const orbitalAngle = THREE.MathUtils.degToRad(dayOfYear / 365.25 * 360);
            const sunDistance = 10;
            const x = sunDistance * Math.cos(orbitalAngle);
            const y = 0;
            const z = sunDistance * Math.sin(orbitalAngle);
            return new THREE.Vector3(x, y, z);
        }

        function tween(target, to, duration) {
            const from = {};
            for (const key in to) from[key] = target[key];
            const start = performance.now();
            const animate = (time) => {
                const elapsed = time - start;
                const t = Math.min(1, elapsed / duration);
                const easedT = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; // easeInOutCubic
                for (const key in to) target[key] = from[key] + (to[key] - from[key]) * easedT;
                if (t < 1) requestAnimationFrame(animate);
            };
            requestAnimationFrame(animate);
        }

        function startApp() {
            try {
                ui = setupUI();
                ui.updateLoader('Iniciando carga de recursos...');
                
                loadAssets((loadedAssets) => {
                    assets = loadedAssets;
                    ui.updateLoader('Creando escena 3D...');
                    three = new ThreeApp(
                        document.getElementById('scene-container'),
                        document.getElementById('labels-container'),
                        assets
                    );
                    setupEventListeners();
                    updateState(true, true);
                    three.start();
                    ui.hideLoader();
                    goToLocation(false);
                });

            } catch (error) {
                console.error("Error fatal durante la inicializaci√≥n:", error);
                if (ui) {
                    ui.updateLoader(`Error: ${error.message}. Por favor, refresca la p√°gina.`);
                }
            }
        }

        startApp();

    </script>
</body>
</html>
