<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Movimiento Parabólico v4.5</title>
    
    <!-- Librerías Externas -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <!-- Fuentes -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Estilos y Configuración de Tailwind -->
    <style type="text/tailwindcss">
        @layer base {
            :root {
                --background: 220 14.3% 95.9%; /* slate-100 */
                --foreground: 224 71.4% 4.1%; /* slate-950 */
                --card: 0 0% 100%; /* white */
                --card-foreground: 224 71.4% 4.1%;
                --primary: 220.9 39.3% 11%; /* slate-800 */
                --primary-foreground: 210 20% 98%; /* slate-50 */
                --secondary: 220 13% 91%; /* slate-200 */
                --secondary-foreground: 220.9 39.3% 11%;
                --muted: 220 13% 91%;
                --muted-foreground: 225 8.9% 46.1%; /* slate-500 */
                --accent: 48 96% 59%; /* amber-500 */
                --border: 220 13% 85%; /* slate-300 */
                --ring: 220.9 39.3% 11%;
                --radius: 0.75rem;
            }
            .dark {
                --background: 222 83.9% 4.9%;
                --foreground: 210 20% 98%;
                --card: 222 47.4% 11.2%;
                --card-foreground: 210 20% 98%;
                --primary: 210 20% 98%;
                --primary-foreground: 222 47.4% 11.2%;
                --secondary: 217 32.6% 17.5%;
                --secondary-foreground: 210 20% 98%;
                --muted: 217 32.6% 17.5%;
                --muted-foreground: 215 20.2% 65.1%;
                --border: 217 32.6% 17.5%;
                --ring: 215 20.2% 65.1%;
            }
            body {
                font-family: 'Inter', sans-serif;
                background-color: hsl(var(--background));
                color: hsl(var(--foreground));
                transition: background-color 0.3s, color 0.3s;
            }
            .canvas-container {
                overflow: hidden;
                cursor: grab;
                position: relative;
            }
            .canvas-container:active {
                cursor: grabbing;
            }
            .modal {
                transition: opacity 0.3s ease, visibility 0.3s ease;
            }
            .modal-content {
                transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            }
            
            input[type="range"] {
                -webkit-appearance: none;
                appearance: none;
                width: 100%;
                height: 6px;
                background: hsl(var(--secondary));
                border-radius: 9999px;
                outline: none;
                transition: background 0.2s;
            }
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px;
                height: 20px;
                background: hsl(var(--primary));
                cursor: pointer;
                border-radius: 50%;
                border: 3px solid hsl(var(--card));
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                transition: transform 0.2s ease;
            }
            input[type="range"]::-webkit-slider-thumb:hover {
                transform: scale(1.1);
            }
            input[type="range"]::-moz-range-thumb {
                width: 20px;
                height: 20px;
                background: hsl(var(--primary));
                cursor: pointer;
                border-radius: 50%;
                border: 3px solid hsl(var(--card));
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }
            details > summary {
                list-style: none;
                cursor: pointer;
            }
            details > summary::-webkit-details-marker {
                display: none;
            }
            details summary .lucide-chevron-down {
                transition: transform 0.2s ease-in-out;
            }
            details[open] summary .lucide-chevron-down {
                transform: rotate(180deg);
            }
        }
    </style>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        border: 'hsl(var(--border))', ring: 'hsl(var(--ring))',
                        background: 'hsl(var(--background))', foreground: 'hsl(var(--foreground))',
                        primary: { DEFAULT: 'hsl(var(--primary))', foreground: 'hsl(var(--primary-foreground))' },
                        secondary: { DEFAULT: 'hsl(var(--secondary))', foreground: 'hsl(var(--secondary-foreground))' },
                        muted: { DEFAULT: 'hsl(var(--muted))', foreground: 'hsl(var(--muted-foreground))' },
                        accent: { DEFAULT: 'hsl(var(--accent))', foreground: 'hsl(var(--accent-foreground))' },
                        card: { DEFAULT: 'hsl(var(--card))', foreground: 'hsl(var(--card-foreground))' },
                    },
                    borderRadius: { lg: "var(--radius)", md: "calc(var(--radius) - 2px)", sm: "calc(var(--radius) - 4px)" },
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                },
            },
        }
    </script>
</head>
<body class="antialiased">
    <div class="relative min-h-screen container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-primary mb-2">
                Movimiento Parabólico
            </h1>
            <p class="text-lg text-muted-foreground">Simulación interactiva de lanzamiento de proyectiles</p>
        </header>

        <!-- Barra de Herramientas Flotante -->
        <div class="absolute top-4 right-4 z-40 bg-card p-2 rounded-full shadow-lg border border-border flex items-center gap-1">
            <button id="home-btn" class="p-2 rounded-full hover:bg-secondary transition-colors focus:ring-2 focus:ring-ring focus:outline-none" aria-label="Reiniciar">
                <i data-lucide="home" class="w-5 h-5 text-primary"></i>
            </button>
            <button id="autoscale-btn" class="p-2 rounded-full hover:bg-secondary transition-colors focus:ring-2 focus:ring-ring focus:outline-none" aria-label="Auto Escala">
                <i data-lucide="locate-fixed" class="w-5 h-5 text-primary"></i>
            </button>
            <div class="relative">
                <button id="palette-btn" class="p-2 rounded-full hover:bg-secondary transition-colors focus:ring-2 focus:ring-ring focus:outline-none" aria-label="Cambiar Color">
                    <i data-lucide="palette" class="w-5 h-5 text-primary"></i>
                </button>
                <div id="color-picker" class="absolute top-full right-0 mt-2 bg-card p-2 rounded-lg shadow-xl border border-border flex gap-2 opacity-0 pointer-events-none transition-all duration-300 scale-95">
                    <!-- Swatches de color se añadirán aquí por JS -->
                </div>
            </div>
            <button id="theme-toggle-btn" class="p-2 rounded-full hover:bg-secondary transition-colors focus:ring-2 focus:ring-ring focus:outline-none" aria-label="Cambiar Tema">
                <i data-lucide="sun" class="w-5 h-5 text-primary block dark:hidden"></i>
                <i data-lucide="moon" class="w-5 h-5 text-primary hidden dark:block"></i>
            </button>
            <button id="help-modal-btn" class="p-2 rounded-full hover:bg-secondary transition-colors focus:ring-2 focus:ring-ring focus:outline-none" aria-label="Mostrar ayuda">
                <i data-lucide="help-circle" class="w-5 h-5 text-primary"></i>
            </button>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 lg:items-start">
            <!-- Columna de Controles y Datos -->
            <div class="space-y-6">
                <div id="parameters-panel" class="bg-card border border-border rounded-2xl shadow-lg p-6">
                    <h2 class="text-2xl font-semibold mb-6 text-primary flex items-center gap-2">
                        <i data-lucide="sliders-horizontal"></i> Parámetros de Lanzamiento
                    </h2>
                    <div class="space-y-6">
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <label for="initialVelocity" class="text-sm font-medium text-muted-foreground">Velocidad Inicial (v₀)</label>
                                <span id="velocityValue" class="px-2 py-1 text-sm font-semibold text-primary bg-secondary rounded-md">45 m/s</span>
                            </div>
                            <input type="range" id="initialVelocity" min="5" max="100" value="45" step="1">
                        </div>
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <label for="launchAngle" class="text-sm font-medium text-muted-foreground">Ángulo (θ)</label>
                                <span id="angleValue" class="px-2 py-1 text-sm font-semibold text-primary bg-secondary rounded-md">45°</span>
                            </div>
                            <input type="range" id="launchAngle" min="1" max="89" value="45" step="1">
                        </div>
                        <div>
                            <div class="flex justify-between items-center mb-1">
                                <label for="gravity" class="text-sm font-medium text-muted-foreground">Gravedad (g)</label>
                                <span id="gravityValue" class="px-2 py-1 text-sm font-semibold text-primary bg-secondary rounded-md">9.8 m/s²</span>
                            </div>
                            <input type="range" id="gravity" min="1" max="20" value="9.8" step="0.1">
                        </div>
                    </div>
                    <div class="grid grid-cols-3 gap-4 mt-6">
                        <button id="startBtn" class="flex items-center justify-center gap-2 py-2 px-4 bg-primary text-primary-foreground font-semibold rounded-lg shadow-md hover:bg-primary/90 transition-all disabled:opacity-50 disabled:cursor-not-allowed"><i data-lucide="play"></i></button>
                        <button id="pauseBtn" class="flex items-center justify-center gap-2 py-2 px-4 bg-secondary text-secondary-foreground font-semibold rounded-lg shadow-md hover:bg-muted transition-all disabled:opacity-50 disabled:cursor-not-allowed" disabled><i data-lucide="pause"></i></button>
                        <button id="resetBtn" class="flex items-center justify-center gap-2 py-2 px-4 bg-secondary text-secondary-foreground font-semibold rounded-lg shadow-md hover:bg-muted transition-all"><i data-lucide="rotate-cw"></i></button>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="bg-card border border-border rounded-2xl shadow-lg p-6">
                        <h2 class="text-xl font-semibold mb-4 text-primary flex items-center gap-2">
                            <i data-lucide="calculator"></i> Datos Teóricos
                        </h2>
                        <div class="space-y-3">
                            <div class="flex justify-between items-center bg-secondary p-2 rounded-lg">
                                <span class="text-sm font-medium text-secondary-foreground">Altura Máxima</span>
                                <span id="maxHeight" class="font-bold text-base text-primary">-</span>
                            </div>
                            <div class="flex justify-between items-center bg-secondary p-2 rounded-lg">
                                <span class="text-sm font-medium text-secondary-foreground">Alcance Máximo</span>
                                <span id="maxRange" class="font-bold text-base text-primary">-</span>
                            </div>
                            <div class="flex justify-between items-center bg-secondary p-2 rounded-lg">
                                <span class="text-sm font-medium text-secondary-foreground">Tiempo de Vuelo</span>
                                <span id="flightTime" class="font-bold text-base text-primary">-</span>
                            </div>
                        </div>
                    </div>

                    <div class="bg-card border border-border rounded-2xl shadow-lg p-6">
                        <h2 class="text-xl font-semibold mb-4 text-primary flex items-center gap-2">
                            <i data-lucide="gauge-circle"></i> Datos en Vivo
                        </h2>
                        <div class="space-y-3">
                            <div class="flex justify-between items-center bg-secondary p-2 rounded-lg">
                                <span class="text-sm font-medium text-secondary-foreground">Tiempo</span>
                                <span id="currentTime" class="font-bold text-base text-primary">0.00 s</span>
                            </div>
                            <div class="flex justify-between items-center bg-secondary p-2 rounded-lg">
                                <span class="text-sm font-medium text-secondary-foreground">Posición X</span>
                                <span id="currentX" class="font-bold text-base text-primary">0.00 m</span>
                            </div>
                            <div class="flex justify-between items-center bg-secondary p-2 rounded-lg">
                                <span class="text-sm font-medium text-secondary-foreground">Posición Y</span>
                                <span id="currentY" class="font-bold text-base text-primary">0.00 m</span>
                            </div>
                             <div class="flex justify-between items-center bg-secondary p-2 rounded-lg">
                                <span class="text-sm font-medium text-secondary-foreground">Velocidad</span>
                                <span id="currentVelocity" class="font-bold text-base text-primary">0.00 m/s</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Columna de Simulación -->
            <div class="lg:col-span-1 min-h-[50vh] lg:min-h-0">
                 <div id="canvas-container" class="canvas-container bg-card border border-border rounded-2xl shadow-lg w-full h-full">
                    <canvas id="simulationCanvas"></canvas>
                    <button id="expand-btn" class="absolute bottom-2 right-2 p-2 rounded-full bg-primary/80 text-primary-foreground hover:bg-primary transition-all backdrop-blur-sm" aria-label="Expandir vista">
                        <i data-lucide="expand"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <footer class="text-center mt-12 py-4 border-t border-border">
            <p class="text-sm text-muted-foreground">
                Autor: Msc Néstor Fabio Montoya y Gemini AI
            </p>
        </footer>

        <!-- Modal de Ayuda -->
        <div id="help-modal" class="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4 opacity-0 pointer-events-none modal">
            <div class="modal-content bg-card border border-border rounded-2xl shadow-2xl w-full max-w-2xl max-h-[90vh] flex flex-col transform scale-95">
                <div class="flex items-center justify-between p-6 border-b border-border">
                    <h2 class="text-xl font-bold text-primary flex items-center gap-2">
                        <i data-lucide="book-open-check"></i> Guía y Fórmulas
                    </h2>
                    <button id="close-help-btn" class="p-2 rounded-md hover:bg-secondary transition-colors">
                        <i data-lucide="x"></i>
                    </button>
                </div>
                <div class="p-6 overflow-y-auto space-y-4">
                    <details class="bg-secondary/50 p-4 rounded-lg" open>
                        <summary class="font-semibold text-lg flex justify-between items-center text-primary">
                            Cómo Interactuar
                            <i data-lucide="chevron-down" class="w-5 h-5"></i>
                        </summary>
                        <ul class="mt-4 list-disc list-inside ml-2 space-y-2 text-muted-foreground">
                            <li><strong>Ajusta Parámetros:</strong> Usa los deslizadores para cambiar velocidad, ángulo y gravedad.</li>
                            <li><strong>Controla la Simulación:</strong> Usa los botones para Iniciar, Pausar y Reiniciar.</li>
                            <li><strong>Zoom (Escritorio):</strong> Usa la rueda del mouse para acercar o alejar.</li>
                            <li><strong>Zoom (Móvil):</strong> Pellizca la pantalla con dos dedos para acercar o alejar.</li>
                            <li><strong>Mover Vista (Paneo):</strong> Haz clic y arrastra (o usa un dedo en móvil) para mover la vista.</li>
                        </ul>
                    </details>
                </div>
            </div>
        </div>
        
        <!-- Modal de Vista Expandida -->
        <div id="expand-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4 opacity-0 pointer-events-none modal">
            <div class="bg-card w-full h-full rounded-2xl shadow-2xl flex flex-col relative">
                <div id="expanded-canvas-container" class="flex-grow h-full w-full relative">
                    <canvas id="expandedCanvas" class="w-full h-full"></canvas>
                    <div id="modal-info-container" class="absolute bottom-4 left-4 w-64">
                         <details class="bg-card/80 backdrop-blur-sm p-3 rounded-lg border border-border text-sm" open>
                            <summary class="font-semibold cursor-pointer flex justify-between items-center text-primary">
                                <span>Datos del Lanzamiento</span>
                                <i data-lucide="chevron-down" class="w-5 h-5 transition-transform"></i>
                            </summary>
                            <div id="modal-info-panel" class="mt-2 space-y-2">
                                <!-- Info se llenará aquí -->
                            </div>
                        </details>
                    </div>
                </div>
                 <button id="close-expand-btn" class="absolute top-4 right-4 p-2 rounded-full bg-primary/80 text-primary-foreground hover:bg-primary transition-all" aria-label="Cerrar vista expandida">
                    <i data-lucide="x"></i>
                </button>
            </div>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- REFERENCIAS AL DOM ---
            const dom = {
                mainCanvas: document.getElementById('simulationCanvas'),
                expandedCanvas: document.getElementById('expandedCanvas'),
                canvasContainer: document.getElementById('canvas-container'),
                expandedCanvasContainer: document.getElementById('expanded-canvas-container'),
                parametersPanel: document.getElementById('parameters-panel'),
                initialVelocitySlider: document.getElementById('initialVelocity'),
                launchAngleSlider: document.getElementById('launchAngle'),
                gravitySlider: document.getElementById('gravity'),
                velocityValue: document.getElementById('velocityValue'),
                angleValue: document.getElementById('angleValue'),
                gravityValue: document.getElementById('gravityValue'),
                startBtn: document.getElementById('startBtn'),
                pauseBtn: document.getElementById('pauseBtn'),
                resetBtn: document.getElementById('resetBtn'),
                maxHeight: document.getElementById('maxHeight'),
                maxRange: document.getElementById('maxRange'),
                flightTime: document.getElementById('flightTime'),
                currentTime: document.getElementById('currentTime'),
                currentX: document.getElementById('currentX'),
                currentY: document.getElementById('currentY'),
                currentVelocity: document.getElementById('currentVelocity'),
                homeBtn: document.getElementById('home-btn'),
                autoscaleBtn: document.getElementById('autoscale-btn'),
                paletteBtn: document.getElementById('palette-btn'),
                themeToggleBtn: document.getElementById('theme-toggle-btn'),
                helpModalBtn: document.getElementById('help-modal-btn'),
                expandBtn: document.getElementById('expand-btn'),
                helpModal: document.getElementById('help-modal'),
                closeHelpBtn: document.getElementById('close-help-btn'),
                expandModal: document.getElementById('expand-modal'),
                closeExpandBtn: document.getElementById('close-expand-btn'),
                colorPicker: document.getElementById('color-picker'),
                modalInfoPanel: document.getElementById('modal-info-panel'),
            };

            const mainCtx = dom.mainCanvas.getContext('2d');
            const expandedCtx = dom.expandedCanvas.getContext('2d');

            // --- ESTADO DE LA SIMULACIÓN ---
            const projectileColors = ['#ef4444', '#3b82f6', '#22c55e', '#f97316', '#a855f7', '#ec4899'];
            let state = {
                v0: 45, angleDeg: 45, g: 9.8,
                t: 0, x: 0, y: 0, v0x: 0, v0y: 0,
                path: [],
                isRunning: false, isPaused: false, animationFrameId: null,
                scale: 10,
                origin: { x: 40, y: 40 },
                panOffset: { x: 0, y: 0 },
                isPanning: false, panStart: { x: 0, y: 0 },
                isPinching: false, initialPinchDistance: 0,
                projectileColorIndex: 0,
            };

            // --- LÓGICA DE MODALES, POPOVERS Y TEMA ---
            function openModal(modal) {
                modal.classList.remove('opacity-0', 'pointer-events-none');
                const content = modal.querySelector('.modal-content') || modal.children[0];
                content.classList.remove('scale-95');
            }

            function closeModal(modal) {
                modal.classList.add('opacity-0');
                const content = modal.querySelector('.modal-content') || modal.children[0];
                content.classList.add('scale-95');
                setTimeout(() => modal.classList.add('pointer-events-none'), 300);
            }
            
            function applyTheme(theme, shouldDraw = true) {
                document.documentElement.classList.toggle('dark', theme === 'dark');
                localStorage.setItem('theme', theme);
                if (shouldDraw) drawAllCanvases();
            }

            function populateColorPicker() {
                dom.colorPicker.innerHTML = '';
                projectileColors.forEach((color, index) => {
                    const swatch = document.createElement('button');
                    swatch.className = 'w-6 h-6 rounded-full cursor-pointer transition-transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-ring';
                    swatch.style.backgroundColor = color;
                    swatch.dataset.index = index;
                    if (index === state.projectileColorIndex) {
                        swatch.classList.add('ring-2', 'ring-offset-2', 'ring-primary');
                    }
                    swatch.addEventListener('click', () => {
                        state.projectileColorIndex = index;
                        closeColorPicker();
                        populateColorPicker();
                        drawAllCanvases();
                    });
                    dom.colorPicker.appendChild(swatch);
                });
            }

            function toggleColorPicker() {
                const picker = dom.colorPicker;
                if (picker.classList.contains('opacity-0')) {
                    picker.classList.remove('opacity-0', 'pointer-events-none', 'scale-95');
                } else {
                    closeColorPicker();
                }
            }
            
            function closeColorPicker() {
                const picker = dom.colorPicker;
                picker.classList.add('opacity-0', 'scale-95');
                setTimeout(() => picker.classList.add('pointer-events-none'), 300);
            }

            // --- LÓGICA DE LA SIMULACIÓN ---
            function calculateTheoreticalValues() {
                const angleRad = state.angleDeg * Math.PI / 180;
                state.v0x = state.v0 * Math.cos(angleRad);
                state.v0y = state.v0 * Math.sin(angleRad);
                const time = (2 * state.v0y) / state.g;
                const range = state.v0x * time;
                const height = (state.v0y ** 2) / (2 * state.g);
                dom.flightTime.textContent = `${time.toFixed(2)} s`;
                dom.maxRange.textContent = `${range.toFixed(2)} m`;
                dom.maxHeight.textContent = `${height.toFixed(2)} m`;
                return { range, height };
            }

            function updateParametersUI() {
                dom.velocityValue.textContent = `${state.v0} m/s`;
                dom.angleValue.textContent = `${state.angleDeg}°`;
                dom.gravityValue.textContent = `${state.g.toFixed(1)} m/s²`;
            }

            function resetSimulationState(shouldDraw = true) {
                if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
                Object.assign(state, { t: 0, x: 0, y: 0, path: [{ x: 0, y: 0 }], isRunning: false, isPaused: false, animationFrameId: null });
                dom.startBtn.disabled = false;
                dom.pauseBtn.disabled = true;
                dom.pauseBtn.classList.add('disabled:opacity-50');
                calculateTheoreticalValues();
                updateRealTimeData();
                if (shouldDraw) {
                    drawAllCanvases();
                }
            }
            
            function fullReset() {
                 resetSimulationState(false);
                 autoScaleAndCenter(dom.mainCanvas);
            }

            function startSimulation() {
                if (state.isRunning && !state.isPaused) return;
                if (state.y < 0) resetSimulationState();
                Object.assign(state, { isRunning: true, isPaused: false });
                dom.startBtn.disabled = true;
                dom.pauseBtn.disabled = false;
                dom.pauseBtn.classList.remove('disabled:opacity-50');
                state.animationFrameId = requestAnimationFrame(animate);
            }

            function pauseSimulation() {
                if (!state.isRunning || state.isPaused) return;
                state.isPaused = true;
                dom.startBtn.disabled = false;
                dom.pauseBtn.disabled = true;
                dom.pauseBtn.classList.add('disabled:opacity-50');
                cancelAnimationFrame(state.animationFrameId);
            }
            
            function animate() {
                if (!state.isRunning || state.isPaused) return;
                const dt = 1 / 60;
                state.t += dt;
                state.x = state.v0x * state.t;
                state.y = state.v0y * state.t - 0.5 * state.g * state.t * state.t;
                state.path.push({ x: state.x, y: state.y });
                updateRealTimeData();
                drawAllCanvases();

                if (state.y < 0) {
                    state.y = 0;
                    state.t = (2 * state.v0y) / state.g;
                    state.x = state.v0x * state.t;
                    state.path[state.path.length - 1] = {x: state.x, y: state.y};
                    updateRealTimeData();
                    drawAllCanvases();
                    pauseSimulation();
                    state.isRunning = false;
                } else {
                    state.animationFrameId = requestAnimationFrame(animate);
                }
            }

            function updateRealTimeData() {
                const vx = state.v0x;
                const vy = state.v0y - state.g * state.t;
                const v = Math.sqrt(vx**2 + vy**2);
                dom.currentTime.textContent = `${state.t.toFixed(2)} s`;
                dom.currentX.textContent = `${state.x.toFixed(2)} m`;
                dom.currentY.textContent = `${Math.max(0, state.y).toFixed(2)} m`;
                dom.currentVelocity.textContent = `${v.toFixed(2)} m/s`;
            }
            
            function updateModalInfo() {
                const { range, height } = calculateTheoreticalValues();
                const angleRad = state.angleDeg * Math.PI / 180;
                const tanTheta = Math.tan(angleRad).toFixed(2);
                const cosTheta = Math.cos(angleRad);
                const gOver2v02cos2 = (state.g / (2 * state.v0**2 * cosTheta**2)).toFixed(4);

                dom.modalInfoPanel.innerHTML = `
                    <p><strong>Altura Máxima:</strong> ${height.toFixed(2)} m</p>
                    <p><strong>Alcance Máximo:</strong> ${range.toFixed(2)} m</p>
                    <p><strong>Tiempo de Vuelo:</strong> ${(2 * state.v0y / state.g).toFixed(2)} s</p>
                    <p class="font-mono mt-2">y(x) = ${tanTheta}x - ${gOver2v02cos2}x²</p>
                `;
            }

            // --- LÓGICA DEL CANVAS Y LAYOUT ---
            function adjustLayout() {
                if (window.innerWidth >= 1024) { // lg breakpoint
                    const panelHeight = dom.parametersPanel.clientHeight;
                    dom.canvasContainer.style.height = `${panelHeight}px`;
                } else {
                    dom.canvasContainer.style.height = '50vh';
                }
                setupCanvas(dom.mainCanvas, dom.canvasContainer);
            }

            function setupCanvas(canvas, container) {
                const rect = container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                // Mantener el tamaño CSS para el layout
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';

                // Ajustar el tamaño real del canvas por el DPR
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;

                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr); // Escalar el contexto para mantener la nitidez
                ctx.pixelRatio = dpr; // Guardar el DPR para compensar en el dibujado
            }

            function niceStep(scale) {
                const targetPx = 70; // Queremos ~70px entre líneas de la cuadrícula
                const raw = targetPx / scale; // Distancia equivalente en unidades del mundo
                const mag = 10 ** Math.floor(Math.log10(raw));
                const nice = [1, 2, 5].find(n => n * mag >= raw) || 10;
                return nice * mag; // p. ej. 20, 50, 100…
            }
            
            function autoScaleAndCenter(canvas) {
                const rect = canvas.parentElement.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) return;
                
                const isMobile = window.innerWidth < 768;
                const originX = isMobile ? 30 : 40;
                const originY = isMobile ? 30 : 40;
                const padding = isMobile ? 10 : 20;

                state.origin = { x: originX, y: originY };

                const { range, height } = calculateTheoreticalValues();
                const yMin = -30;
                const xMax = Math.max(range * 1.1, isMobile ? 40 : 80);
                const yMax = Math.max(height * 1.2, 60);
                const ySpan = yMax - yMin;

                const viewWidth = rect.width - originX - padding;
                const viewHeight = rect.height - originY - padding;

                const scaleX = viewWidth / xMax;
                const scaleY = viewHeight / ySpan;

                state.scale = Math.min(scaleX, scaleY);
                
                if (!isFinite(state.scale) || state.scale <= 0) {
                    state.scale = isMobile ? 2 : 5; // Fallback
                }
                
                state.panOffset = { x: 0, y: yMin * state.scale };
                drawAllCanvases();
            }
            
            function drawAllCanvases() {
                drawScene(dom.mainCanvas, mainCtx);
                if (dom.expandModal && !dom.expandModal.classList.contains('opacity-0')) {
                    drawScene(dom.expandedCanvas, expandedCtx);
                }
            }

            function drawScene(canvas, ctx) {
                const container = canvas.parentElement;
                if (!container) return;
                const rect = container.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) return;

                const isDark = document.documentElement.classList.contains('dark');
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Usar canvas.width/height
                
                const originY = rect.height - state.origin.y;
                
                ctx.save();
                ctx.translate(state.origin.x + state.panOffset.x, originY + state.panOffset.y);
                ctx.scale(state.scale, -state.scale);

                drawGridAndPath(ctx, rect, isDark);
                
                ctx.restore();
                drawAxes(ctx, rect, isDark);
            }

            function drawGridAndPath(ctx, rect, isDark) {
                const gridColor = isDark ? '#374151' : '#e5e7eb';
                
                // Compensar el grosor de línea por el DPR
                ctx.lineWidth = 1 / (state.scale * ctx.pixelRatio);
                
                const step = niceStep(state.scale);

                const {x: startX, y: endY} = screenToWorld(rect, 0, 0);
                const {x: endX, y: startY} = screenToWorld(rect, rect.width, rect.height);

                ctx.strokeStyle = gridColor;
                for (let x = Math.floor(startX / step) * step; x < endX; x += step) {
                    if (x < 0) continue;
                    ctx.beginPath(); ctx.moveTo(x, startY); ctx.lineTo(x, endY); ctx.stroke();
                }
                for (let y = Math.floor(startY / step) * step; y < endY; y += step) {
                    ctx.beginPath(); ctx.moveTo(startX, y); ctx.lineTo(endX, y); ctx.stroke();
                }

                if (state.path.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(state.path[0].x, state.path[0].y);
                    state.path.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.strokeStyle = projectileColors[state.projectileColorIndex];
                    ctx.lineWidth = 2 / (state.scale * ctx.pixelRatio);
                    ctx.stroke();
                }

                ctx.beginPath();
                const radius = Math.abs(4 / state.scale);
                ctx.arc(state.x, state.y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = projectileColors[state.projectileColorIndex];
                ctx.fill();
            }

            function drawAxes(ctx, rect, isDark) {
                const color = isDark ? '#cbd5e1' : '#4b5563';
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 1.5 / ctx.pixelRatio;
                // Compensar tamaño de fuente por el DPR
                ctx.font = `600 ${12 / ctx.pixelRatio}px Inter`;
                
                const originY = rect.height - state.origin.y;
                const originX = state.origin.x;

                const transformedOrigin = {
                    x: originX + state.panOffset.x,
                    y: originY + state.panOffset.y
                };

                ctx.beginPath();
                ctx.moveTo(transformedOrigin.x, 0);
                ctx.lineTo(transformedOrigin.x, rect.height);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, transformedOrigin.y);
                ctx.lineTo(rect.width, transformedOrigin.y);
                ctx.stroke();

                const step = niceStep(state.scale);
                const {x: startX, y: endY} = screenToWorld(rect, 0, 0);
                const {x: endX, y: startY} = screenToWorld(rect, rect.width, rect.height);

                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                for (let x = Math.ceil(startX / step) * step; x < endX; x += step) {
                    if (x <= 0) continue;
                    const screenX = x * state.scale + transformedOrigin.x;
                    if (screenX < originX + 15 || screenX > rect.width - 15) continue;
                    ctx.fillText(x.toFixed(0), screenX, transformedOrigin.y + 8);
                    ctx.beginPath();
                    ctx.moveTo(screenX, transformedOrigin.y - 4);
                    ctx.lineTo(screenX, transformedOrigin.y + 4);
                    ctx.stroke();
                }

                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                for (let y = Math.floor(startY / step) * step; y < endY; y += step) {
                    if (y === 0) continue;
                    const screenY = transformedOrigin.y - y * state.scale;
                    if (screenY < 15 || screenY > rect.height - 15) continue;
                    
                    ctx.fillText(y.toFixed(0), transformedOrigin.x - 10, screenY);
                    ctx.beginPath();
                    ctx.moveTo(transformedOrigin.x - 4, screenY);
                    ctx.lineTo(transformedOrigin.x + 4, screenY);
                    ctx.stroke();
                }
            }
            
            function screenToWorld(rect, sx, sy) {
                const originY = rect.height - state.origin.y;
                return {
                    x: (sx - state.origin.x - state.panOffset.x) / state.scale,
                    y: (sy - originY - state.panOffset.y) / -state.scale
                };
            }

            // --- EVENT LISTENERS ---
            window.addEventListener('resize', () => {
                adjustLayout();
                autoScaleAndCenter(dom.mainCanvas);
            });
            
            [dom.initialVelocitySlider, dom.launchAngleSlider, dom.gravitySlider].forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const id = e.target.id;
                    const value = parseFloat(e.target.value);
                    if (id === 'initialVelocity') state.v0 = value;
                    if (id === 'launchAngle') state.angleDeg = value;
                    if (id === 'gravity') state.g = value;
                    
                    updateParametersUI();
                    if (!state.isRunning) {
                        resetSimulationState();
                        autoScaleAndCenter(dom.mainCanvas);
                    }
                });
            });

            dom.startBtn.addEventListener('click', startSimulation);
            dom.pauseBtn.addEventListener('click', pauseSimulation);
            dom.resetBtn.addEventListener('click', () => {
                resetSimulationState();
                autoScaleAndCenter(dom.mainCanvas);
            });
            dom.homeBtn.addEventListener('click', fullReset);
            dom.autoscaleBtn.addEventListener('click', () => autoScaleAndCenter(dom.mainCanvas));
            dom.helpModalBtn.addEventListener('click', () => openModal(dom.helpModal));
            dom.closeHelpBtn.addEventListener('click', () => closeModal(dom.helpModal));
            dom.themeToggleBtn.addEventListener('click', () => {
                const isDark = document.documentElement.classList.contains('dark');
                applyTheme(isDark ? 'light' : 'dark');
            });
            dom.paletteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleColorPicker();
            });
            
            if (dom.expandBtn) {
                dom.expandBtn.addEventListener('click', () => {
                    openModal(dom.expandModal);
                    setupCanvas(dom.expandedCanvas, dom.expandedCanvasContainer);
                    autoScaleAndCenter(dom.expandedCanvas);
                    updateModalInfo();
                });
            }
            if(dom.closeExpandBtn) {
                dom.closeExpandBtn.addEventListener('click', () => closeModal(dom.expandModal));
            }

            // --- MANEJO DE INTERACCIONES DEL CANVAS (ESCRITORIO Y MÓVIL) ---
            function addCanvasListeners(canvas) {
                if (!canvas) return;
                
                let touchStartPos = { x: 0, y: 0 };
                let lastPanPos = { x: 0, y: 0 };
                let isDragging = false;

                canvas.addEventListener('wheel', e => {
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const mousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                    const worldPosBeforeZoom = screenToWorld(rect, mousePos.x, mousePos.y);
                    
                    const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
                    state.scale *= zoomFactor;

                    const worldPosAfterZoom = screenToWorld(rect, mousePos.x, mousePos.y);
                    
                    state.panOffset.x += (worldPosAfterZoom.x - worldPosBeforeZoom.x) * state.scale;
                    state.panOffset.y -= (worldPosAfterZoom.y - worldPosBeforeZoom.y) * state.scale;

                    drawAllCanvases();
                }, { passive: false });

                canvas.addEventListener('mousedown', e => {
                    state.isPanning = true;
                    lastPanPos = { x: e.clientX, y: e.clientY };
                    canvas.style.cursor = 'grabbing';
                });

                window.addEventListener('mousemove', e => {
                    if (!state.isPanning) return;
                    const dx = e.clientX - lastPanPos.x;
                    const dy = e.clientY - lastPanPos.y;
                    state.panOffset.x += dx;
                    state.panOffset.y += dy;
                    lastPanPos = { x: e.clientX, y: e.clientY };
                    drawAllCanvases();
                });

                window.addEventListener('mouseup', () => {
                    if (state.isPanning) {
                        state.isPanning = false;
                        canvas.style.cursor = 'grab';
                    }
                });

                canvas.addEventListener('touchstart', e => {
                    if (e.touches.length === 1) {
                        const touch = e.touches[0];
                        touchStartPos = { x: touch.clientX, y: touch.clientY };
                        lastPanPos = { x: touch.clientX, y: touch.clientY };
                        isDragging = false;
                    } else if (e.touches.length === 2) {
                        e.preventDefault();
                        state.isPinching = true;
                        state.initialPinchDistance = getPinchDistance(e.touches);
                    }
                }, { passive: true });

                canvas.addEventListener('touchmove', e => {
                    if (state.isPinching && e.touches.length === 2) {
                        e.preventDefault();
                        const newDist = getPinchDistance(e.touches);
                        const zoomFactor = newDist / state.initialPinchDistance;
                        
                        const rect = canvas.getBoundingClientRect();
                        const center = getPinchCenter(e.touches, rect);
                        const worldPosBefore = screenToWorld(rect, center.x, center.y);

                        state.scale *= zoomFactor;
                        
                        const worldPosAfter = screenToWorld(rect, center.x, center.y);
                        state.panOffset.x += (worldPosAfter.x - worldPosBefore.x) * state.scale;
                        state.panOffset.y -= (worldPosAfter.y - worldPosBefore.y) * state.scale;

                        state.initialPinchDistance = newDist;
                        drawAllCanvases();

                    } else if (!state.isPinching && e.touches.length === 1) {
                        const touch = e.touches[0];
                        const dx = touch.clientX - touchStartPos.x;
                        const dy = touch.clientY - touchStartPos.y;

                        if (!isDragging) {
                            if (Math.abs(dx) > Math.abs(dy) + 2) {
                                isDragging = true;
                            } else {
                                return;
                            }
                        }
                        
                        if(isDragging) {
                            e.preventDefault();
                            const panDx = touch.clientX - lastPanPos.x;
                            const panDy = touch.clientY - lastPanPos.y;
                            state.panOffset.x += panDx;
                            state.panOffset.y += panDy;
                            lastPanPos = { x: touch.clientX, y: touch.clientY };
                            drawAllCanvases();
                        }
                    }
                }, { passive: false });

                canvas.addEventListener('touchend', e => {
                    if (e.touches.length < 2) state.isPinching = false;
                    if (e.touches.length < 1) isDragging = false;
                });

                function getPinchDistance(touches) {
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    return Math.sqrt(dx * dx + dy * dy);
                }
                
                function getPinchCenter(touches, rect) {
                    return {
                        x: ((touches[0].clientX + touches[1].clientX) / 2) - rect.left,
                        y: ((touches[0].clientY + touches[1].clientY) / 2) - rect.top,
                    };
                }
            }
            
            addCanvasListeners(dom.mainCanvas);
            addCanvasListeners(dom.expandedCanvas);
            
            document.addEventListener('click', (e) => {
                if (dom.colorPicker && !dom.colorPicker.contains(e.target) && !dom.paletteBtn.contains(e.target)) {
                    closeColorPicker();
                }
            });

            // --- INICIALIZACIÓN ---
            function init() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                applyTheme(savedTheme, false);
                populateColorPicker();
                adjustLayout();
                fullReset();
                lucide.createIcons();
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init();
            }
        });
    </script>
</body>
</html>
